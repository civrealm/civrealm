{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CivRealm","text":"<p>CivRealm is a reinforcement learning environment for the open-source strategy game Freeciv-web based on Freeciv. The goal is to provide a simple interface for AI researchers to train agents on Freeciv.</p>"},{"location":"#install-and-setup","title":"Install and Setup","text":""},{"location":"#system-requirements","title":"System Requirements","text":"<p>Civrealm requires Python version &gt;=3.8.</p> <p>In order to test the civrealm on http://localhost, please download the docker image from: https://drive.google.com/file/d/1tf32JpwqGN7AtUPe0Q4fIRkE4icSM-51/view?usp=sharing.</p> <p>:warning: Please make sure you have installed the latest docker engine and docker-compose. Using older versions of docker may result in unexpected erorrs.</p>"},{"location":"#installation","title":"Installation","text":"<p>We suggest using Conda to create a clean virtual environment for installation.</p> <p>Installation through the source code in the civrealm folder:</p> <pre><code>cd civrealm\npip install -e .\n</code></pre>"},{"location":"#testing-the-installation","title":"Testing the installation","text":"<p>To test if the installation is successful, run</p> <pre><code>test_civrealm \n</code></pre> <p>To test with multiple players, run:</p> <pre><code>test_civrealm --minp=2 --username=myagent\n</code></pre> <p>Then start another terminal and run:</p> <pre><code>test_civrealm --username=myagent1\n</code></pre> <p>To observe the game play, you can access http://localhost:8080/ on a browser. Then, please click the \"Online Games\" button. You can find the running game under the \"MULTIPLAYER\" tab.</p>"},{"location":"#trouble-shooting","title":"Trouble Shooting","text":"<p>The following are some common issues that you may encounter when running the code. If you encounter any other issues, please feel free to open an issue.</p> <ul> <li> <p>Note that each game corresponds to one port on the server. If one game just stops and you immediately start a new game connecting to the same port as the stopped game, the new game may encounter errors and exit. Our training has used ''Ports.get()'' in ''civrealm/freeciv/utils/port_utils.py'' to avoid the situation. If you want to configure the client port and start a client manually, you need to find the available ports by checking the 'Online Games/MULTIPLAYER' tab in localhost:8080.</p> </li> <li> <p>If firefox keeps loading the page, please try to add the following line to <code>/etc/hosts</code>:</p> <pre><code>127.0.0.1 maxcdn.bootstrapcdn.com\n127.0.0.1 cdn.webglstats.com\n</code></pre> </li> </ul>"},{"location":"advanced_materials/game_setting/","title":"Game Setting","text":"<p>The game setting is specified in the \"default_settings.yaml\" file under the civrealm folder. The details of the game setting are as follows:</p>"},{"location":"advanced_materials/game_setting/#basic-settings-for-game-play","title":"Basic settings for game play","text":"<ul> <li> <p>username: the user name used to log in the game.</p> </li> <li> <p>max_turns: the maximum number of turns per game. Game will end after the turn number reaches this limit.</p> </li> <li> <p>host: the url that hosts the game.</p> </li> <li> <p>client_port: the port to be connected by the client. Used in the single-thread mode. For parallel running, the client port is chosen from available ports.</p> </li> <li> <p>multiplayer_game: whether to start a multiplayer game or single-player game. By default: True.</p> </li> <li> <p>hotseat_game: whether to use the hotseat mode in single-player game. By default: False.</p> </li> <li> <p>wait_for_observer: whether to wait for an observer join before start the game. By default: False. If set to True, the game will not start until a user observes the game through the browser.</p> </li> <li> <p>server_timeout: we consider the server is timeout after it does not respond any messages for server_timeout seconds. In pytest, we automatically set it as 5 in conftest.py.</p> </li> <li> <p>wait_for_timeout: sometimes we perform an invalid action and cannot receive the response to wait_for_packs. We wait for wait_for_timeout seconds and clear the wait_for_packs to prevent the process from stucking.</p> </li> <li> <p>begin_turn_timeout: sometimes the server is stucked for unknown reasons and will not return begin_turn packet. We wait for begin_turn_timeout seconds before we close the environment. This configuration should be CAREFULLY set when playing with human or llm agents because they may use more than 60 seconds for each of their turn. In those cases, the server will send begin_turn packet only after they finish their turns.</p> </li> <li> <p>pytest: whether in pytest mode. By default: False. In pytest, we automatically set it as True in conftest.py.</p> </li> <li> <p>self_play: whether start the self-play mode. By default: False. If set to True, the first player first log in the game will be the host and the following players will add increasing index to their username in order to log in the same game.</p> </li> <li> <p>score_window: the number of episode scores maintained in the ParallelTensorEnv.</p> </li> <li> <p>aifill: number of AI players to be initialized when a game starts.</p> </li> <li> <p>maxplayers: the maximum number of players allowed to join a game.</p> </li> <li> <p>minp: the minimum number of players needed for starting a game.</p> </li> <li> <p>allowtake: decides whether can take control/observe a player. Please check the details of this setting in the Freeciv instruction. By default: HAhadOo.</p> </li> <li> <p>autotoggle: whether allow an AI to control a player when the previous player disconnects. By default: disabled.</p> </li> <li> <p>endvictory: whether end the game when some players succeed under victory conditions, option: enabled, disabled. By default: enabled.</p> </li> <li> <p>victories: the options for victory condition. If a certain victory condition is not set, the calculation logic for that victory condition will be skipped. Available options: SPACERACE|ALLIED|CULTURE. By default: \"SPACERACE|ALLIED\".</p> </li> <li> <p>openchatbox: whether to open chatbox in the web interface, option: enabled, disabled. By default: enabled.</p> </li> <li> <p>ruleset: the ruleset to be used. By default: classic.</p> </li> <li> <p>runner_type: the type of runner. By default: \"parallel\".</p> </li> </ul>"},{"location":"advanced_materials/game_setting/#settings-for-parallel-running","title":"Settings for parallel running","text":"<ul> <li> <p>batch_size_run: how many envs run simultaneously to sample experience.</p> </li> <li> <p>epoch_num: how many epochs to run. Each epoch runs batch_size_run envs.</p> </li> <li> <p>port_start: the port used by the first env. The other parallel envs use those ports following this port.</p> </li> </ul>"},{"location":"advanced_materials/game_setting/#settings-for-debug","title":"Settings for debug","text":"<ul> <li> <p>record_action_and_observation: records the game state and available actions at every step. By default: False. Warning: generates many log files if True. </p> </li> <li> <p>take_screenshot: take screenshots during playing. By default: False. wait_for_observer flag should be set to True if enable screenshots. Exec \"update_javascript_for_clean_screenshot\" command first to get cleaner screenshots. Warning: generates many log files if True.</p> </li> <li> <p>global_view_screenshot: take the screenshot of global view. By default: True.</p> </li> <li> <p>sleep_time_after_turn: time to wait after each turn.</p> </li> <li> <p>autosave: by default: True. If set to true, automatically save game in the beginning of every turn. The save will be deleted in the end of that turn unless the program finds some issues in that turn.</p> </li> <li> <p>interrupt_save: by default: False. If set to true, will save the game when using KeyboardInterrupt. Note that when enabling this setting, we should disable autosave. Otherwise, the game will be saved in the beginning of every turn and cannot be saved again when using KeyboardInterrupt.</p> </li> <li> <p>password: password used to login to the freeciv web account. By default: civrealm.</p> </li> <li> <p>load_game: the name of save data to be loaded. By default: \"\". </p> </li> <li> <p>randomly_generate_seeds: whether to use randomly generated seeds for running games. By default: True. If set to True, the following random seeds (mapseed, gameseed, agentseed) are ignored. </p> </li> <li> <p>mapseed: the seed for generating a map. The same seed leads to the same map.</p> </li> <li> <p>gameseed: the seed for fixing the behavior of random outputs.</p> </li> <li> <p>agentseed: the seed for fixing the action sequence when game/map are fixed.</p> </li> <li> <p>tensor_debug: whether print debug information for tensor env. By default: False.</p> </li> </ul>"},{"location":"advanced_materials/minigame/","title":"Mini-Game","text":"<p>Due to the multifaceted aspects of a full game, including economic expansion, military development, diplomatic negotiations, cultural construction, and technological research, we have devised mini games to address each component individually. Each mini-game is designed with specific objectives, varying difficulty levels, step-based rewards, and an overall game score. The designed details could be found in the paper.</p> <p>By the end of this tutorial, you will be able to</p> <ul> <li>Understand the basic setting of mini-game</li> <li>Initialize mini-game by using API for random initialization or manual specification</li> <li>Create a new mini-game by yourself</li> </ul>"},{"location":"advanced_materials/minigame/#setting","title":"\ud83c\udfae Setting","text":""},{"location":"advanced_materials/minigame/#game-status","title":"\ud83c\udfc1 Game Status","text":"<p>To describe whether a mini-game is over, the game-ending conditions include:</p> <ul> <li>The game score being greater than or equal to the goal score</li> <li>Reaching the maximum number of rounds set for the game</li> </ul> <p>The enumerated values are as follows: src/civrealm/envs/freeciv_minitask_env.py<pre><code>@unique\nclass MinitaskGameStatus(ExtendedEnum):\n    MGS_END_GAME = 1\n    MGS_IN_GAME = 0\n</code></pre></p>"},{"location":"advanced_materials/minigame/#game-difficulty","title":"\ud83d\udd25 Game Difficulty","text":"<p>Based on the richness of terrain resources, the comparison of unit quantities, and other information, we designed the difficulty level of the mini-game.</p> <p>The enumerated values are as follows: src/civrealm/envs/freeciv_minitask_env.py<pre><code>@unique\nclass MinitaskDifficulty(ExtendedEnum):\n    MD_EASY = 'easy'\n    MD_NORMAL = 'normal'\n    MD_HARD = 'hard'\n</code></pre></p>"},{"location":"advanced_materials/minigame/#victory-status","title":"\ud83c\udfc6 Victory Status","text":"<p>In the mini-game, the player\u2019s current victory status can be represented as: failure, success, and unknown. The unknown state signifies that the game has not yet concluded, while the determination of failure and success only occurs after the game ends.</p> <p>The enumerated values are as follows: src/civrealm/envs/freeciv_minitask_env.py<pre><code>@unique\nclass MinitaskPlayerStatus(ExtendedEnum):\n    MPS_SUCCESS = 1\n    MPS_FAIL = 0\n    MPS_UNKNOWN = -1\n</code></pre></p>"},{"location":"advanced_materials/minigame/#supported-types","title":"\ud83d\uddfa\ufe0f Supported Types","text":"<p>We have designed the following 10 types of mini-games:</p> Category ID Name Introduction Development 1 development_build_city Move settler to suitable areas for building a city. 2 development_build_infra Command workers to build infrastructures for improving cities. 3 development_citytile_wonder Arrange work tiles to speed up producing a world wonder. 4 development_transport Transport settlers by ships to another continent and build cities. Battle 5 battle_[ancient_era,industry_era,info_era,medieval,modern_era] Defeat enemy units on land tiles (units from various ages). 6 battle_attack_city Conquer an enemy city. 7 battle_defend_city Against enemy invasion for a certain number of turns. 8 battle_naval Defeat enemy fleet on the ocean (with Middle Times frigates). 9 battle_naval_modern Defeat enemy fleet on the ocean (with several classes of modern ships). Diplomacy 10 diplomacy_trade_tech Trade technologies with another civilization. <p>The enumerated values are as follows: src/civrealm/envs/freeciv_minitask_env.py<pre><code>@unique\nclass MinitaskType(ExtendedEnum):\n    MT_DEVELOPMENT_BUILD_CITY = \"development_build_city\"\n    MT_DEVELOPMENT_CITYTILE_WONDER = \"development_citytile_wonder\"\n    MT_DEVELOPMENT_BUILD_INFRA = \"development_build_infra\"\n    MT_DEVELOPMENT_TRANSPORT = \"development_transport\"\n    MT_BATTLE_ANCIENT = \"battle_ancient_era\"\n    MT_BATTLE_INDUSTRY = \"battle_industry_era\"\n    MT_BATTLE_INFO = \"battle_info_era\"\n    MT_BATTLE_MEDIEVAL = \"battle_medieval\"\n    MT_BATTLE_MODERN = \"battle_modern_era\"\n    MT_BATTLE_NAVAL_MODERN = \"battle_naval_modern\"\n    MT_BATTLE_NAVAL = \"battle_naval\"\n    MT_BATTLE_ATTACK_CITY = \"battle_attack_city\"\n    MT_BATTLE_DEFEND_CITY = \"battle_defend_city\"\n    MT_DIPLOMACY_TRADE_TECH = \"diplomacy_trade_tech\"\n</code></pre></p>"},{"location":"advanced_materials/minigame/#prepare-dataset","title":"Prepare Dataset","text":"<p>Before you start the mini-game, you need to load the mini-game designed archives into the server\u2019s laoding archive path.</p> <p>The steps are as follows:</p> <p>Step 1:  find your used version on the releases page, and download the data files for the mini-game to your local path such as <code>/tmp/minigame/</code></p> <p>Step 2:  copy the data files, and extract them into the corresponding docker savegame path. If the docker image is <code>freeciv-web</code>, and the tomcat version is <code>10</code>, then execute the following commands: <pre><code>#!/bin/bash\nimage=\"freeciv-web\"\ntomcat_version=\"tomcat10\"\nlocal_path=\"/tmp/minigame/\"\n\nmkdir $local_path\ncd $local_path\ndocker exec -it $image rm -r /var/lib/$tomcat_version/webapps/data/savegames/minitask/\ndocker exec -it $image mkdir -p /var/lib/$tomcat_version/webapps/data/savegames/minitask/\nfor minitask_zip in `ls`\ndo\n    docker cp $minitask_zip $image:/var/lib/$tomcat_version/webapps/data/savegames/minitask/\n    docker exec -it $image unzip -o /var/lib/$tomcat_version/webapps/data/savegames/minitask/$minitask_zip -d /var/lib/$tomcat_version/webapps/data/savegames/minitask/\n    docker exec -it $image rm /var/lib/$tomcat_version/webapps/data/savegames/minitask/$minitask_zip\ndone\n</code></pre></p>"},{"location":"advanced_materials/minigame/#initialize-random-mini-game","title":"Initialize Random Mini-Game","text":"<p><code>freeciv/FreecivMinitask-v0</code> is the environment of mini-game. When the mini game is launched, its internal design will randomly select a game of any type and any difficulty.</p> <pre><code>from civrealm.agents import ControllerAgent\nimport gymnasium\n\nenv = gymnasium.make('freeciv/FreecivMinitask-v0')\nagent = ControllerAgent()\nobservations, info = env.reset()\n</code></pre>"},{"location":"advanced_materials/minigame/#choose-specific-mini-game","title":"Choose Specific Mini-Game","text":"<p>Inside <code>reset</code> method of environment, you can use the parameter <code>minitask_pattern</code> to choose specific mini-game. The fields are as follows:</p> <p><code>type</code>: the type of mini-game, see the available options MinitaskType</p> <p><code>level</code>: the difficulty of mini-game, see the available options MinitaskDifficulty</p> <p><code>id</code>: the id of mini-game, the available range is 0 to MAX_ID</p> <p>For example, if you want to set the type as <code>development_build_city</code> and the difficulty as <code>easy</code>, then the code is as follows: <pre><code>from civrealm.agents import ControllerAgent\nimport gymnasium\n\nenv = gymnasium.make(\"freeciv/FreecivMinitask-v0\")\nobservations, info = env.reset(minitask_pattern={\n    \"type\": \"development_build_city\", \n    \"level\": \"easy\"})\n</code></pre></p>"},{"location":"advanced_materials/minigame/#definition-of-mini-game-messages","title":"Definition of Mini-game messages","text":"<p>The messages of mini-game are passed from the server to the agent at each trigger point by lua script setting. The general json structure of message is: <pre><code>{\n    \"task\": \"minitask\",\n    \"name\": \"${name of minitask}\",\n    \"status\": ${MinitaskGameStatus},\n    \"turn\": ${turn of game},\n    \"metrics\": [{\n        \"mini_score\": ${mini_score},\n        \"mini_goal\": ${mini_goal},\n        \"max_turn\": ${max_turn},\n        \"is_mini_success\": ${MinitaskPlayerStatus},\n    }]\n}\n</code></pre></p> <ul> <li> <p>The <code>task</code> is used to label the source of message. The <code>task</code> for messages from mini-game is set to be <code>minitask</code>.</p> </li> <li> <p>The final element of <code>metrics</code> records the final game review status for each trigger action, which is actually used in civrealm. In the dict structure of <code>metrics</code> elements, we can  define other useful auxiliary information</p> </li> <li> <p>The <code>metrics.mini_score</code> is used to record the agent's mini-game score.</p> </li> <li> <p>The <code>metrics.mini_goal</code> is used to record the agent's mini-game goal, which is to set the game victory score threshold.</p> </li> <li> <p>The <code>metrics.max_turn</code> is limited to a certain number of turns. If the maximum number of turns is exceeded, failure is returned in civrealm.</p> </li> <li> <p>The <code>metrics.is_mini_success</code> is used to record the player succeed status of player, which is the same as <code>success</code> defined of minitask info in civrealm. If succeed, it requires that <code>mini_score&gt;=mini_goal</code>.</p> </li> </ul>"},{"location":"advanced_materials/minigame/#play-mini-game-as-a-random-agent","title":"Play mini-game as a random agent","text":"<p>Generally speaking, it is difficult for random agents to win the battle and diplomacy mini-game, and in the development mini-game, the game victory condition will be met with a certain probability.</p> <p>The commands are as follows: <pre><code>cd civrealm/\npython src/civrealm/random_game_minitask.py\n</code></pre></p> <p>After executing the commands, the log will be like: <pre><code>Step: 0, Turn: 1, Reward: 0.0, Terminated: False, Truncated: False, Action: ('tech', 'cur_player', 'set_tech_goal_Conscription_18')\n        Minitask Info: {'status': 0, 'success': -1, 'human_cnt': 11.0, 'ai_cnt': 12.0, 'mini_score': -1.0, 'mini_goal': 11.0, 'max_turn': 50, 'human_leader_alive': 1, 'ai_leader_alive': 1, 'is_mini_success': -1}\nStep: 1, Turn: 1, Reward: 0.0, Terminated: False, Truncated: False, Action: ('unit', 108, 'goto_1')\n        Minitask Info: {'status': 0, 'success': -1, 'human_cnt': 11.0, 'ai_cnt': 12.0, 'mini_score': -1.0, 'mini_goal': 11.0, 'max_turn': 50, 'human_leader_alive': 1, 'ai_leader_alive': 1, 'is_mini_success': -1}\n</code></pre></p> <p>In the log, We can see that each step displays some fields from the above definitions as <code>Definition of Mini-game messages</code>, and some are auxiliary fields designed by mini-game itself such as <code>human_leader_alive</code>.</p>"},{"location":"advanced_materials/minigame/#create-new-mini-game","title":"Create new Mini-Game","text":"<p>The general pipeline of creating new mini-game is as follows:</p> <pre><code>graph TD\n    A(Be clear about \\nwhat to do) --&gt; D(Use gtk tool to generate basic archive)\n    D --&gt; F(Set mini-game messages by lua script)\n    F --&gt; E(&lt;b&gt;Large batch auto random generation&lt;/b&gt;)\n    E --&gt; H{Mini-Game Validation}\n    H --&gt; |Not Pass| J{Bug from \\nCivrealm}\n    J --&gt; |Yes| K[Contribute bugfix for Civrealm]\n    J --&gt; |No| D\n    H --&gt; |Pass| I[Create new Mini-Game successfully]</code></pre>"},{"location":"advanced_materials/minigame/#be-clear-about-what-to-do","title":"Be clear about what to do","text":"<p>The basic design mechanisms of mini-game are:</p> <ul> <li> <p>Single Goal. Don't consider multiple learning objectives at the same time, otherwise the game will become less mini after more influences are introduced.</p> </li> <li> <p>Feasible Action. In the huge space of action, be clear about which actions are relevant to your goal, and avoid too many unrelated or paradoxical actions in actionable actions.</p> </li> <li> <p>Computable Reward. In addition to the final score at the end of the game, the reward for each step or turn can be defined and calculated.</p> </li> </ul> <p>At the beginning of designing a mini-game, you have to answer the following questions:</p> <ul> <li> <p>What type of the mini-game do you want to design?</p> </li> <li> <p>When does the mini-game end?</p> </li> <li> <p>How to calculate the reward for each step?</p> </li> <li> <p>How to set the difficulty of the game? </p> </li> </ul> <p>These questions will be given appropriate suggestions to some extent below.</p>"},{"location":"advanced_materials/minigame/#use-gtk-tool-to-generate-basic-archive","title":"Use gtk tool to generate basic archive","text":""},{"location":"advanced_materials/minigame/#set-mini-game-messages-by-lua-script","title":"Set mini-game messages by lua script","text":"<p>Warning</p> <p>Donot modify sav file directly in general. Because the fields in the sav file have dependencies on each other, if you modify a field without noticing some other fields that need to be modified at the same time, it will cause the server to load the sav file unsuccessfully.</p> <p>The lua script is used to send mini-game messages to the agent. Before adding the lua script for basic sav file, you need to understand the archive format of freeciv and how it defines the game state internally.</p> <ul> <li> <p>The suffix of the game archive file is <code>.sav</code>, and usually compressed as a compressed file with <code>.xz</code> or <code>.zst</code> suffix. If the archive file is compressed, you need to use the corresponding component to decompress it to get the sav file.</p> </li> <li> <p>In the sav file, there are many key-value structures to describe the current game state. Here, We list the main tags and their explanations:</p> </li> </ul> Tag Description savefile A set of definition rules for common elements, including activity, technology, etc. game The base state values of the game, such as turn, launch order and year. script The script of lua. At the inherent or designed trigger points of the game, obtain the internal data of the game, calculate the custom game state values, and send out event messages. settings The setting of freeciv server. map The global map of world, and distribution information of resources, cities, and land development. player0 The game status of a player with an id of 0, including information such as how many units and cities the player0 have.  score0 The scores of a player with an id of 0, including information such as total score and unhappy degree. research The progress of research for each player.  <p>Here, we focus on the implementation of <code>script</code> tag. In the sav file, the format of <code>script</code> as below: <pre><code>[script]\ncode=${lua code}$\n</code></pre> <code>{lua code}</code> is the code of lua language that implements to send mini-game messages.</p> <p>Firstly, you need to consider which trigger points to set during the game in order to change the status value of the mini-game, and set up the end conditions of the game. All trigger action functions can be referred to the Lua Reference manual. We list the common trigger action functions as follows:</p> (return) type function name/variable arguments comments Boolean turn_begin (Number turn, Number year) Trigger at each turn begining. Boolean city_built (City city) Trigger at city built. Boolean unit_lost (Unit unit, Player loser, String reason) Trigger at unit lost. Boolean city_destroyed (City city, Player loser, Player destroyer) Trigger at city destroyed. <p>In addition, we developed the following trigger action function to enhance the perception of the freeciv-server game process:</p> (return) type function name/variable arguments comments Boolean game_started (Player player) Trigger at game started. The `game_started` supports to display the welcome message at the beginning of the game, if you use the `turn_begin` to set turn=1 to display the welcome message, it will not take effect, because the game thinks that it is already in the current turn running state, and will not trigger the judgment of the `turn_begin`, although this function can be achieved by setting the technique of phase=1 additionally, but the setting will cause other players to act first, which will bring unexpected problems. Boolean game_ended (Player player) Trigger at game ended. Since freeciv-server has many internal conditions for ending the game, all the end states of the game can be recycled by using game_ended. If game ended, set mini-game `status`=1(MinitaskGameStatus.MGS_END_GAME). Boolean action_finished_worker_build (City city) Trigger at activity finished by worker. Boolean action_started_worker_build (City city) Trigger at activity started by worker. <p>Secondly, calculate the mini-score and mini-goal. </p> <p>Taking mini-game <code>battle</code> as an example, the formula for calculating the <code>mini-score</code> is as follows:</p> <p>\\(\\text{mini_score}=\\text{unit_cnt_of_human_player} - \\text{unit_cnt_of_ai_player}\\)</p> <p>The larger the mini_score is, the more units of human player survives, the better, and the more units of ai player is destroyed, the better. The <code>mini-goal</code> is setting to</p> <p>\\(\\text{mini_goal}=\\text{unit_cnt_of_human_player}\\)</p> <p>It means that if you want to satisfy mini_score&gt;=mini_goal to succeed, you need to destroy all units of ai player.</p> <p>Finally, wrap your message of mini-game and send it out throught E.SCRIPT event. The event function is: <pre><code>notify.event(nil, nil, E.SCRIPT, _(${message}))\n</code></pre></p>"},{"location":"advanced_materials/minigame/#large-batch-auto-random-generation","title":"Large batch auto random generation","text":"<p>The auto random generation is supported by the <code>freeciv-sav</code> module. To implement a new mini-game dependently, you should inherit class <code>SavTaskGenerator</code>. For example,</p> <pre><code>from freeciv_sav.tasks.sav_task import SavTaskGenerator\n\nclass NewMiniGameGenerator(SavTaskGenerator):\n    def create_new_game(self, lua_conf:str, *args, **kwargs):\n        \"\"\"\n        Create new game.\n\n        Parameters\n        ----------\n        lua_conf : str\n            The lua script designed.\n        \"\"\"\n        while True:\n            {Call the functions from tools to implement randomization}\n            break\n        return\n</code></pre> <p>The tools contains <code>map_op</code> <code>unit_op</code>, <code>player_op</code>, <code>game_op</code>, etc. The main functions of tools are as follows:</p> OP function name comments map_op gen_random_walk_map Randomly generate mini-game map by random walk with modifying the terrain, resource and shape of land. unit_op set_location_with_cluster Randomly set location for units. player_op set_name Assignment the name of mini-game. game_op set_init_status Set game status initially. <p>Use these functions to help you to implement large batch auto random generation of mini-game. </p>"},{"location":"advanced_materials/minigame/#mini-game-validation","title":"Mini-Game Validation","text":"<p>Check your mini-game inside <code>freeciv-web</code>, and test the mini-game to follow the section <code>Play mini-game as a random agent</code>. If the tests pass, congratulations on completing the task for creating new mini-game.</p>"},{"location":"advanced_materials/tensor_agent/","title":"Tensor Agent","text":"<p>Welcome to Civrealm Tensor Agent! This documentation will guide you through the process of training tensor-based agents, specifically using the Proximal Policy Optimization (PPO), in the Civrealm Environment. We will first provide an overview of the Civrealm Tensor Env, followed by instructions on how to use the Civtensor repository to train a PPO agent on this environment.</p>"},{"location":"advanced_materials/tensor_agent/#civrealm-tensor-environment","title":"\ud83c\udf0f Civrealm Tensor Environment","text":"<p>The Civrealm Tensor Environment is a reinforcement learning environment wrapped upon Civrealm Base Env specifically designed for training agents using tensor-based algorithms. This environment </p> <ul> <li>provides flattened, tensorized observation and action spaces,</li> <li>restrict available actions in order to reduce meaningless actions,</li> <li>offers delta game score as a basic reward for RL agents,</li> <li>provide parallel environments with batched inputs and outputs for efficient training, </li> </ul> <p>and various modular wrappers which are open to customize your own environment.</p>"},{"location":"advanced_materials/tensor_agent/#using-civtensor-repository","title":"\ud83c\udfc3Using Civtensor Repository","text":"<p>The civtensor repository is a collection of code and utilities that provide a baseline implementation for training reinforcement learning agents using tensor-based algorithms.</p> <p>It includes an implementation of the PPO algorithm, which we will use to train our agents in the Civrealm Tensor Environment.</p>"},{"location":"advanced_materials/tensor_agent/#getting-started","title":"\ud83c\udfcc\ufe0f Getting Started","text":"<p>To get started, follow these steps:</p> <ol> <li>Clone the tensor-baseline repository from GitHub and enter the directory:    <pre><code>cd civtensor\n</code></pre></li> <li>Install the required dependencies by navigating to the repository directory and running:    <pre><code>pip install -e .\n</code></pre></li> <li>Train PPO baseline for fullgame     <pre><code>cd examples\npython train.py\n</code></pre></li> <li> <p>Train PPO baseline for minitasks:     <pre><code>cd examples\npython run.py\n</code></pre>    This will start the training process, the agent interacts with the environment, collects experiences, and updates its policy using the PPO algorithm.</p> </li> <li> <p>Monitor the training progress and evaluate the agent's performance using the provided metrics and visualization tools in the tensor-baseline repository.     <pre><code>cd examples/results/freeciv_tensor_env/$game_type/ppo/installtest/seed-XXXXXXXXX\n# where $game_type = fullgame or minitask\ntensorboard logs/\n</code></pre> Congratulations! You have successfully set up the Civrealm Tensor Agent and trained a PPO agent on the Civrealm Tensor Environment using the tensor-baseline repository.</p> </li> </ol>"},{"location":"advanced_materials/tensor_agent/#conclusion","title":"Conclusion","text":"<p>In this guide, we introduced the Civrealm Tensor Environment and explained how to use the tensor-baseline repository to train a PPO agent on this environment. We encourage you to explore the various features and customization options available in the Civrealm Tensor Agent and experiment with different reinforcement learning algorithms to further enhance your agent's performance. Happy training!</p>"},{"location":"api_reference/api/","title":"API Reference","text":""},{"location":"api_reference/api/#envs","title":"Envs","text":""},{"location":"api_reference/api/#envs.freeciv_base_env.FreecivBaseEnv","title":"<code>envs.freeciv_base_env.FreecivBaseEnv</code>","text":"<p>             Bases: <code>Env</code>, <code>EzPickle</code></p> <p>Basic CivRealm environment</p> Source code in <code>src/civrealm/envs/freeciv_base_env.py</code> <pre><code>class FreecivBaseEnv(gymnasium.Env, utils.EzPickle):\n    \"\"\" Basic CivRealm environment \"\"\"\n    metadata = {'render_modes': ['human']}\n\n    def __init__(\n            self, username: str = fc_args['username'],\n            client_port=None,\n            is_minitask=False):\n        self.username = username\n        self.is_minitask = is_minitask\n        # Record whether the env is currently running.\n        self.running = False\n\n        # Create dummy controller to retrieve action_space and observation_space.\n        self.civ_controller = CivController(username=self.username,\n                                            visualize=fc_args['debug.take_screenshot'],\n                                            is_minitask=self.is_minitask)\n        self._action_space = self.civ_controller.action_space\n        self._observation_space = self.civ_controller.observation_space\n        self.set_up_recording()\n        utils.EzPickle.__init__(self, self.username, client_port, self.is_minitask)\n\n    def set_up_screenshots(self):\n        self._screenshot_step_count = 0\n        curr_date_time = str(datetime.date.today()) + \"_\" + str(datetime.datetime.now().time().strftime('%H-%M-%S.%f'))\n        self.screenshot_dir = os.path.join(\n            os.path.dirname(fc_logger.handlers[0].baseFilename),\n            'screenshots', self.username + \"_\" + str(self.get_port()) + \"_\" + curr_date_time)\n        os.makedirs(self.screenshot_dir, exist_ok=True)\n\n    def set_up_recording(self):\n        # For recording purposes. self.record_step_count only increases when recording is enabled.\n        self._record_step_count = 0\n        self.recording_dir = os.path.join(\n            os.path.dirname(fc_logger.handlers[0].baseFilename),\n            'recordings', fc_args['username'])\n        os.makedirs(self.recording_dir, exist_ok=True)\n\n    @property\n    def action_space(self):\n        self._action_space = self.civ_controller.action_space\n        return self._action_space\n\n    @property\n    def observation_space(self):\n        self._observation_space = self.civ_controller.observation_space\n        return self._observation_space\n\n    def _take_screenshot(self):\n        if fc_args['debug.take_screenshot'] is False:\n            return\n        turn = self.civ_controller.get_turn()\n        screenshot_filename = os.path.join(\n            self.screenshot_dir, f'turn_{turn:03d}_step_{self._screenshot_step_count:04d}.png')\n        self.civ_controller.take_screenshot(screenshot_filename)\n        self._screenshot_step_count += 1\n\n    def _record_to_file(self, name, content, default_json_encoder=None):\n        if fc_args['debug.record_action_and_observation'] is False:\n            return\n\n        turn = self.civ_controller.get_turn()\n        self._recording_base_filename = os.path.join(\n            self.recording_dir, f'turn_{turn:03d}_step_{self._record_step_count:04d}')\n        with open(f'{self._recording_base_filename}_{name}.json', 'w') as f:\n            json.dump(content, f, skipkeys=True, sort_keys=True, default=default_json_encoder)\n\n    def _record_observation(self, observation):\n        self._record_to_file('state', observation, lambda x: x.get_bitvector_in_ascii()\n                             if isinstance(x, BitVector) else x.tolist())\n\n    def _record_action(self, available_actions, action):\n        self._record_to_file('available_action', available_actions, lambda x: x.encode_to_json())\n        if action:\n            self._record_to_file('chosen_action', action, lambda x: x.encode_to_json())\n        self._record_step_count += 1\n\n    def _get_info_and_observation(self):\n        info, observation = self.civ_controller.get_info_and_observation()\n        self._record_observation(observation)\n        return info, observation\n\n    def _get_reward(self):\n        return self.civ_controller.get_reward()\n\n    def _get_terminated(self):\n        return self.civ_controller.game_has_terminated()\n\n    def _get_truncated(self):\n        return self.civ_controller.game_has_truncated()\n\n    def step(self, action):\n        self.civ_controller.perform_action(action)\n        try:\n            info, observation = self._get_info_and_observation()\n            reward = self._get_reward()\n            terminated = self._get_terminated()\n            truncated = self._get_truncated()\n\n            available_actions = info['available_actions']\n            self._record_action(available_actions, action)\n            self._take_screenshot()\n        except Exception as e:\n            fc_logger.error(repr(e))\n            reward = 0\n            info = None\n            observation = None\n            terminated = False\n            truncated = True\n\n        return observation, reward, terminated, truncated, info\n\n    def get_port(self):\n        return self.civ_controller.client_port\n\n    def get_username(self):\n        return self.civ_controller.clstate.username\n\n    def get_playerid(self):\n        return self.civ_controller.player_ctrl.my_player_id\n\n    def reset(self, seed=None, options=None, client_port=None, **kwargs):\n        # If call reset when the env is still running, we close it first.\n        if self.running:\n            print('Close running environment before reset.')\n            self.close()\n        if client_port is None:\n            client_port = Ports.get()\n        print(f'Reset with port: {client_port}')\n        fc_logger.debug(f'Reset with port: {client_port}')\n        # self.civ_controller = CivController(username=self.username, client_port=client_port, visualize=fc_args['debug.take_screenshot'], is_minitask=self.is_minitask)\n        # self._action_space = self.civ_controller.action_space\n        # self._observation_space = self.civ_controller.observation_space\n        self.civ_controller.reset_civ_controller(client_port)\n\n        self.set_up_screenshots()\n\n        if seed is not None:\n            fc_args['debug.randomly_generate_seeds'] = False\n            fc_args['debug.mapseed'] = seed\n            fc_args['debug.agentseed'] = seed\n\n        # fc_logger.debug(f'begin_logged: {self.civ_controller.clstate.begin_logged}, turn_active: {self.civ_controller.turn_manager.turn_active}')\n        # Log in and get the first info and observation\n        self.civ_controller.init_network()\n        info, observation = self._get_info_and_observation()\n        # Log in success, set running as True\n        self.running = True\n        return observation, info\n\n    def get_game_results(self):\n        game_results = self.civ_controller.game_ctrl.game_results\n        return dict(sorted(game_results.items()))\n\n    def evaluate_game(self):\n        game_scores = self.civ_controller.request_scorelog()\n        return self.civ_controller.game_ctrl.get_game_scores(game_scores)\n\n    def plot_game_scores(self):\n        players, tags, turns, evaluations = self.evaluate_game()\n        if evaluations is None:\n            return\n\n        plot_game_scores_folder = (f\"plot_game_scores/{time.strftime('%Y-%m-%d-%H-%M-%S')}-\"\n                                   f\"{self.civ_controller.client_port}\")\n        if not os.path.exists(plot_game_scores_folder):\n            os.makedirs(plot_game_scores_folder)\n\n        player_colors = self.civ_controller.player_ctrl.get_player_colors()\n        for ptag in EVALUATION_TAGS:\n            if ptag not in evaluations:\n                continue\n\n            plt.figure()\n            for player_id in evaluations[ptag].keys():\n                scores = evaluations[ptag][player_id]\n                x_1 = players[player_id]['start_turn']\n                x_axis = range(x_1, x_1 + len(scores))\n                plt.plot(x_axis, scores, color=player_colors[player_id], label='player' + '_' + str(player_id))\n\n            plt.legend()\n            pfile = os.path.join(plot_game_scores_folder, ptag + '.png')\n            plt.savefig(pfile)\n            plt.close()\n\n    def get_final_score(self):\n        _, _, _, evaluations = self.evaluate_game()\n        score = {}\n        if evaluations != None:\n            for tag in EVALUATION_TAGS:\n                score[tag] = evaluations[tag][self.civ_controller.player_ctrl.my_player_id][-1]\n        return score\n\n    def render(self):\n        \"\"\"Render the environment based on freeciv-web.\n        \"\"\"\n        pass\n\n    def close(self):\n        # fc_logger.info(f'Env port: {self.get_port()} closes ....')\n        self.civ_controller.close()\n        self.running = False\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_base_env.FreecivBaseEnv.render","title":"<code>render()</code>","text":"<p>Render the environment based on freeciv-web.</p> Source code in <code>src/civrealm/envs/freeciv_base_env.py</code> <pre><code>def render(self):\n    \"\"\"Render the environment based on freeciv-web.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_minitask_env.FreecivMinitaskEnv","title":"<code>envs.freeciv_minitask_env.FreecivMinitaskEnv</code>","text":"<p>             Bases: <code>FreecivBaseEnv</code></p> <p>CivRealm environment for mini-game.</p> Source code in <code>src/civrealm/envs/freeciv_minitask_env.py</code> <pre><code>class FreecivMinitaskEnv(FreecivBaseEnv):\n    \"\"\" CivRealm environment for mini-game. \"\"\"\n\n    def __init__(self, username: str = DEFAULT_TASK, client_port: int = fc_args['client_port']):\n        super().__init__(username=username, client_port=client_port, is_minitask=True)\n        fc_args['username'] = username\n        set_logging_file('.', username)\n        self.filename = None\n        self.task_type = None\n        fc_args['debug.autosave'] = False\n        self._last_minitask_score = None\n        self.overall_mini_score = 0\n\n    @staticmethod\n    def get_minitask(name, minitask_pattern, max_id):\n        if not isinstance(minitask_pattern, dict):\n            minitask_pattern = dict()\n\n        minitask_id = minitask_pattern.get('id', random.randint(0, max_id))\n        minitask_level = minitask_pattern.get('level', random.choice(MinitaskDifficulty.list()))\n        minitask_type = minitask_pattern.get('type', random.choice(MinitaskType.list()))\n\n        if minitask_type not in MinitaskType.list():\n            raise ValueError(f\"Not supported type as {minitask_pattern}. The suppported list is {MinitaskType.list()}!\")\n        if minitask_id &gt; max_id or minitask_id &lt; 0:\n            raise ValueError(f\"Not supported id as {minitask_id}. The suppported range is [0, {max_id}]!\")\n        if minitask_level not in MinitaskDifficulty.list():\n            raise ValueError(\n                f\"Not supported diffculty as {minitask_level}. The suppported list is {MinitaskDifficulty.list()}!\")\n\n        minitask = '{}_T1_task_{}_level_{}_id_{}'.format(name, minitask_type, minitask_level, minitask_id)\n        fc_logger.warning(f\"Randomly selected minitask {minitask}!\")\n        return minitask\n\n    def _get_info_and_observation(self):\n        info, observation = super()._get_info_and_observation()\n        if 'player' in info['available_actions'] and self.task_type in BATTLE_MINITASK_LIST:\n            del info['available_actions']['player']\n        return info, observation\n\n    def _set_minitask_info(self, info):\n        info['minitask'] = {\n            'status': self._get_game_status(),\n            'success': self._get_success(),\n        }\n        info['minitask'].update(self._get_detail())\n        return\n\n    def reset(self, seed=None, options=None, minitask_pattern=None, max_id=MAX_ID):\n        \"\"\"\n        Reset the mini-game environment as fully random game or specific game.\n\n        Parameters\n        ----------\n        seed : int\n            Random seed for game.\n        options : dict\n            Env configuration.\n        minitask_pattern : dict\n            Assignment the following fields to return a specified game:\\n\n            `type`: the type of mini-game, see the available options MinitaskType;\\n\n            `level`: the difficulty of mini-game, see the available options MinitaskDifficulty;\\n\n            `id`: the id of mini-game, the available range is 0 to MAX_ID.\\n\n            If a field is not assigned a value, the field will be randomly selected within the feasible domain.\n        max_id : int\n            The max id of mini-game.\n        \"\"\"\n\n        self.set_minitask(seed, minitask_pattern, max_id)\n        observations, info = super().reset(seed, options)\n        self._set_minitask_info(info)\n        return observations, info\n\n    def set_minitask(self, seed, minitask_pattern, max_id):\n        random.seed(seed)\n        minitask = self.get_minitask(fc_args['username'], minitask_pattern, max_id)\n        self.filename = minitask\n        self.task_type = re.match(r\"{}_T\\d+_task_([a-z]+)_.*\".format(fc_args['username']), minitask)[1]\n        self.civ_controller.set_parameter('debug.load_game', minitask)\n        return\n\n    def minitask_has_terminated(self):\n        \"\"\"\n        In addition to the game termination judgment of the full game, \n        the mini-game has additional conditions for the end of the game process.\n        \"\"\"\n        minitask_info = self.civ_controller.get_turn_message()\n        if any([msg.get(\"status\") == MinitaskGameStatus.MGS_END_GAME.value for msg in minitask_info]):\n            return True\n        return False\n\n    def _get_terminated(self):\n        return self.civ_controller.game_has_terminated() or self.minitask_has_terminated()\n\n    def _get_step_msg(self, key):\n        minitask_results = self.civ_controller.get_turn_message()\n        for msg in minitask_results[::-1]:\n            if key in msg:\n                if key == 'metrics':\n                    return msg[key][-1]\n                return msg[key]\n        return\n\n    def _get_reward(self):\n        metrics = self._get_step_msg('metrics')\n        current_score = 0.0\n        if metrics is None:\n            return current_score\n        if self._last_minitask_score is None:\n            self._last_minitask_score = metrics['mini_score']\n        current_score = metrics['mini_score'] - self._last_minitask_score\n        self._last_minitask_score = metrics['mini_score']\n        self.overall_mini_score = metrics['mini_score']\n        return current_score\n\n    def _get_game_status(self):\n        status = self._get_step_msg('status')\n        if status is None:\n            return MinitaskGameStatus.MGS_IN_GAME.value\n        return status\n\n    def _get_success(self):\n        metrics = self._get_step_msg('metrics')\n        if metrics is None:\n            return MinitaskPlayerStatus.MPS_UNKNOWN.value\n        return metrics.get('is_mini_success')\n\n    def _get_detail(self):\n        metrics = self._get_step_msg('metrics')\n        if metrics is None:\n            return dict()\n        return metrics\n\n    def step(self, action):\n        observation, reward, terminated, truncated, info = super().step(action)\n        self._set_minitask_info(info)\n        return observation, reward, terminated, truncated, info\n\n    def get_game_results(self):\n        game_results = self.civ_controller.game_ctrl.game_results\n        minitask_results = self.civ_controller.get_turn_message()\n        results = dict(sorted(game_results.items()))\n        results.update({\"minitask_sav\": self.filename})\n        results.update({\"minitask_type\": self.task_type})\n        results.update(dict(minitask=minitask_results))\n        return results\n\n    def get_final_score(self):\n        score = {}\n        score['mini_score'] = self.overall_mini_score\n        return score\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_minitask_env.FreecivMinitaskEnv.minitask_has_terminated","title":"<code>minitask_has_terminated()</code>","text":"<p>In addition to the game termination judgment of the full game,  the mini-game has additional conditions for the end of the game process.</p> Source code in <code>src/civrealm/envs/freeciv_minitask_env.py</code> <pre><code>def minitask_has_terminated(self):\n    \"\"\"\n    In addition to the game termination judgment of the full game, \n    the mini-game has additional conditions for the end of the game process.\n    \"\"\"\n    minitask_info = self.civ_controller.get_turn_message()\n    if any([msg.get(\"status\") == MinitaskGameStatus.MGS_END_GAME.value for msg in minitask_info]):\n        return True\n    return False\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_minitask_env.FreecivMinitaskEnv.reset","title":"<code>reset(seed=None, options=None, minitask_pattern=None, max_id=MAX_ID)</code>","text":"<p>Reset the mini-game environment as fully random game or specific game.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>Random seed for game.</p> <code>None</code> <code>options</code> <code>dict</code> <p>Env configuration.</p> <code>None</code> <code>minitask_pattern</code> <code>dict</code> <p>Assignment the following fields to return a specified game:</p> <p><code>type</code>: the type of mini-game, see the available options MinitaskType;</p> <p><code>level</code>: the difficulty of mini-game, see the available options MinitaskDifficulty;</p> <p><code>id</code>: the id of mini-game, the available range is 0 to MAX_ID.</p> <p>If a field is not assigned a value, the field will be randomly selected within the feasible domain.</p> <code>None</code> <code>max_id</code> <code>int</code> <p>The max id of mini-game.</p> <code>MAX_ID</code> Source code in <code>src/civrealm/envs/freeciv_minitask_env.py</code> <pre><code>def reset(self, seed=None, options=None, minitask_pattern=None, max_id=MAX_ID):\n    \"\"\"\n    Reset the mini-game environment as fully random game or specific game.\n\n    Parameters\n    ----------\n    seed : int\n        Random seed for game.\n    options : dict\n        Env configuration.\n    minitask_pattern : dict\n        Assignment the following fields to return a specified game:\\n\n        `type`: the type of mini-game, see the available options MinitaskType;\\n\n        `level`: the difficulty of mini-game, see the available options MinitaskDifficulty;\\n\n        `id`: the id of mini-game, the available range is 0 to MAX_ID.\\n\n        If a field is not assigned a value, the field will be randomly selected within the feasible domain.\n    max_id : int\n        The max id of mini-game.\n    \"\"\"\n\n    self.set_minitask(seed, minitask_pattern, max_id)\n    observations, info = super().reset(seed, options)\n    self._set_minitask_info(info)\n    return observations, info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_tensor_env.FreecivTensorEnv","title":"<code>envs.freeciv_tensor_env.FreecivTensorEnv</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>CivRealm environment with Tensor actions</p> Source code in <code>src/civrealm/envs/freeciv_tensor_env.py</code> <pre><code>class FreecivTensorEnv(Wrapper):\n    \"\"\"CivRealm environment with Tensor actions\"\"\"\n\n    metadata = FreecivBaseEnv.metadata\n\n    def __init__(\n        self,\n        username: str = fc_args[\"username\"],\n        client_port: int = fc_args[\"client_port\"],\n        config: dict = default_tensor_config,\n    ):\n        tensor_env = GameOverScoreInfo(\n            TensorWrapper(\n                env=PenalizeConsecutiveTurnDoneReward(\n                    FreecivBaseEnv(username=username, client_port=client_port),\n                    penalty=-1,\n                ),\n                config=config,\n            )\n        )\n        super().__init__(tensor_env)\n        self._cached_reset_result = super().reset()\n        # reset during init to get valid obs space\n        self.first_reset = True\n\n    def reset(self, **kwargs):\n        if self.first_reset and len(kwargs) == 0:\n            # use cached reset during init for first reset\n            obs, info = self._cached_reset_result\n            self.first_reset = False\n            return obs, info\n        return super().reset(**kwargs)\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_llm_env.FreecivLLMEnv","title":"<code>envs.freeciv_llm_env.FreecivLLMEnv</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>CivRealm environment with llm actions</p> Source code in <code>src/civrealm/envs/freeciv_llm_env.py</code> <pre><code>class FreecivLLMEnv(Wrapper):\n    \"\"\"CivRealm environment with llm actions\"\"\"\n\n    metadata = FreecivBaseEnv.metadata\n\n    def __init__(self,\n                 username: str = fc_args[\"username\"],\n                 client_port: int = fc_args[\"client_port\"]):\n\n        llm_env = LLMWrapper(FreecivBaseEnv(username=username, client_port=client_port))\n        super().__init__(llm_env)\n</code></pre>"},{"location":"api_reference/api/#wrappers","title":"Wrappers","text":""},{"location":"api_reference/api/#envs.freeciv_wrapper.tensor_wrapper.TensorWrapper","title":"<code>envs.freeciv_wrapper.tensor_wrapper.TensorWrapper</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>TensorWrapper is used to make Civrealm environment tensorized by converting observations from FreecivBaseEnv into tensors and tensor actions back to actions compatible with FreecivBaseEnv.</p> <p>TensorWrapper is composed <code>TensorBase</code>, <code>TensorAction</code>, <code>TensorObservation</code> and <code>CacheLastObs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>FreecivBaseEnv</code> required <code>config</code> <code>dict</code> <p>tensor env configuration</p> <code>default_tensor_config</code> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>tensor wrapper configuration</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/tensor_wrapper.py</code> <pre><code>class TensorWrapper(Wrapper):\n    \"\"\"\n    TensorWrapper is used to make Civrealm environment tensorized by converting\n    observations from FreecivBaseEnv into tensors and tensor actions back to actions compatible with\n    FreecivBaseEnv.\n\n    TensorWrapper is composed `TensorBase`, `TensorAction`, `TensorObservation`\n    and `CacheLastObs`.\n\n    Parameters\n    ----------\n    env\n    config:\n        tensor env configuration\n\n    Attributes\n    ----------\n    config: dict\n        tensor wrapper configuration\n\n    \"\"\"\n\n    def __init__(self, env: FreecivBaseEnv, config: dict = default_tensor_config):\n        self.config = config\n        super().__init__(\n            CacheLastObs(\n                TensorObservation(TensorAction(TensorBase(env, config=config)))\n            )\n        )\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.tensor_wrapper.TensorBase","title":"<code>envs.freeciv_wrapper.tensor_wrapper.TensorBase</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>A basic wrapper that deals with config loading and entity id recording,  required by all tensor-related wrappers.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>FreecivBaseEnv</code> required <code>config</code> <code>dict</code> <p>tensor env configuration</p> <code>default_tensor_config</code> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>A dict that specifies all configurations related to tensor wrapper.</p> <code>my_player_id</code> <code>int</code> <p>My player id.</p> <code>unit_ids</code> <code>list</code> <p>A sorted list of my unit ids.</p> <code>city_ids</code> <code>list</code> <p>A sorted list of my city ids.</p> <code>others_unit_ids</code> <code>list</code> <p>A sorted list of others unit ids.</p> <code>others_city_ids</code> <code>list</code> <p>A sorted list of others city ids.</p> <code>dipl_ids</code> <code>list</code> <p>A list of others player ids.</p> <code>units</code> <code>dict</code> <p>ruleset information about units.</p> <code>unit_types</code> <code>list</code> <p>A list of all unit types.</p> <code>unit_costs</code> <code>list</code> <p>A list of int indicating unit costs.</p> <code>improvements</code> <code>dict</code> <p>Ruleset information about city improvements.</p> <code>impr_costs</code> <code>list</code> <p>A list of int indicating city improvements costs.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/tensor_base_wrapper.py</code> <pre><code>class TensorBase(Wrapper):\n    \"\"\"\n    A basic wrapper that deals with config loading and entity id recording, \n    required by all tensor-related wrappers.\n\n\n    Parameters\n    ----------\n    env: FreecivBaseEnv\n    config: dict\n        tensor env configuration\n\n    Attributes\n    ---------\n    config: dict\n        A dict that specifies all configurations related to tensor wrapper.\n    my_player_id: int\n        My player id.\n    unit_ids: list\n        A sorted list of my unit ids.\n    city_ids: list\n        A sorted list of my city ids.\n    others_unit_ids: list\n        A sorted list of others unit ids.\n    others_city_ids: list\n        A sorted list of others city ids.\n    dipl_ids : list\n        A list of others player ids.\n    units : dict\n        ruleset information about units.\n    unit_types :list\n        A list of all unit types.\n    unit_costs : list\n        A list of int indicating unit costs.\n    improvements : dict\n        Ruleset information about city improvements.\n    impr_costs :list\n        A list of int indicating city improvements costs.\n\n    \"\"\"\n\n    def __init__(self, env: FreecivBaseEnv, config: dict = default_tensor_config):\n        self.config = config\n        self.my_player_id = -1\n\n        # mutable ids\n        self.unit_ids = []\n        self.city_ids = []\n        self.others_unit_ids = []\n        self.others_city_ids = []\n        self.dipl_ids = []\n\n        # ruleset\n        self.units = {}\n        self.unit_types = []\n        self.unit_costs = []\n        self.improvements = {}\n        self.impr_costs = []\n\n        super().__init__(env)\n\n    def update_sequence_ids(self, observation):\n        \"\"\"\n        Use city, unit and dipl information in observation to update ids.\n        \"\"\"\n        self.unit_ids = sorted(\n            list(\n                k\n                for k in observation.get(\"unit\", {}).keys()\n                if observation[\"unit\"][k][\"owner\"] == self.my_player_id\n            )\n        )\n        self.others_unit_ids = sorted(\n            list(\n                k\n                for k in observation.get(\"unit\", {}).keys()\n                if observation[\"unit\"][k][\"owner\"] != self.my_player_id\n            )\n        )\n        self.city_ids = sorted(\n            list(\n                k\n                for k in observation.get(\"city\", {}).keys()\n                if observation[\"city\"][k][\"owner\"] == self.my_player_id\n            )\n        )\n        self.others_city_ids = sorted(\n            list(\n                k\n                for k in observation.get(\"city\", {}).keys()\n                if observation[\"city\"][k][\"owner\"] != self.my_player_id\n            )\n        )\n        self.dipl_ids = [\n            player\n            for player in sorted(observation.get(\"dipl\", {}).keys())\n            if player != self.my_player_id\n        ]\n\n    def update_config(self):\n        \"\"\"\n        Update config using ruleset information at the start of the turn.\n        \"\"\"\n        self.units = self.unwrapped.civ_controller.rule_ctrl.unit_types\n        self.unit_types = [self.units[i][\"name\"] for i in range(len(self.units))]\n        self.unit_costs = [self.units[i][\"build_cost\"] for i in range(len(self.units))]\n        self.improvements = self.unwrapped.civ_controller.rule_ctrl.improvements\n        self.impr_costs = [\n            self.improvements[i][\"build_cost\"] for i in range(len(self.improvements))\n        ]\n        self.config[\"obs_ops\"][\"unit\"][\"type_rule_name\"] = onehotifier_maker(\n            self.unit_types\n        )\n        self.config[\"obs_ops\"][\"rules\"][\"build_cost\"] = lambda _: np.array(\n            self.unit_costs + self.impr_costs\n        )\n\n    def reset(self, *args, **kwargs):\n        obs, info = self.env.reset(*args, **kwargs)\n        self.my_player_id = self.unwrapped.civ_controller.player_ctrl.my_player_id\n\n        self.update_config()\n        self.update_sequence_ids(obs)\n        return obs, info\n\n    def step(self, *args, **kwargs):\n        obs, reward, terminated, truncated, info = self.env.step(*args, **kwargs)\n        self.update_sequence_ids(obs)\n        return obs, reward, terminated, truncated, info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.tensor_wrapper.TensorBase.update_config","title":"<code>update_config()</code>","text":"<p>Update config using ruleset information at the start of the turn.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/tensor_base_wrapper.py</code> <pre><code>def update_config(self):\n    \"\"\"\n    Update config using ruleset information at the start of the turn.\n    \"\"\"\n    self.units = self.unwrapped.civ_controller.rule_ctrl.unit_types\n    self.unit_types = [self.units[i][\"name\"] for i in range(len(self.units))]\n    self.unit_costs = [self.units[i][\"build_cost\"] for i in range(len(self.units))]\n    self.improvements = self.unwrapped.civ_controller.rule_ctrl.improvements\n    self.impr_costs = [\n        self.improvements[i][\"build_cost\"] for i in range(len(self.improvements))\n    ]\n    self.config[\"obs_ops\"][\"unit\"][\"type_rule_name\"] = onehotifier_maker(\n        self.unit_types\n    )\n    self.config[\"obs_ops\"][\"rules\"][\"build_cost\"] = lambda _: np.array(\n        self.unit_costs + self.impr_costs\n    )\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.tensor_wrapper.TensorBase.update_sequence_ids","title":"<code>update_sequence_ids(observation)</code>","text":"<p>Use city, unit and dipl information in observation to update ids.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/tensor_base_wrapper.py</code> <pre><code>def update_sequence_ids(self, observation):\n    \"\"\"\n    Use city, unit and dipl information in observation to update ids.\n    \"\"\"\n    self.unit_ids = sorted(\n        list(\n            k\n            for k in observation.get(\"unit\", {}).keys()\n            if observation[\"unit\"][k][\"owner\"] == self.my_player_id\n        )\n    )\n    self.others_unit_ids = sorted(\n        list(\n            k\n            for k in observation.get(\"unit\", {}).keys()\n            if observation[\"unit\"][k][\"owner\"] != self.my_player_id\n        )\n    )\n    self.city_ids = sorted(\n        list(\n            k\n            for k in observation.get(\"city\", {}).keys()\n            if observation[\"city\"][k][\"owner\"] == self.my_player_id\n        )\n    )\n    self.others_city_ids = sorted(\n        list(\n            k\n            for k in observation.get(\"city\", {}).keys()\n            if observation[\"city\"][k][\"owner\"] != self.my_player_id\n        )\n    )\n    self.dipl_ids = [\n        player\n        for player in sorted(observation.get(\"dipl\", {}).keys())\n        if player != self.my_player_id\n    ]\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.action_wrapper.TensorAction","title":"<code>envs.freeciv_wrapper.action_wrapper.TensorAction</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>A wrapper that defines tensor action spaces,  transforms tensor actions into actions that could be handeled by FreecivBaseEnv instance, and adds masks to observations.</p> <p>TensorAction wrapper is composed of five wrappers, including <code>TruncateDiplCity</code>, <code>DiplomacyLoop</code>, <code>CombineTechResearchGoal</code>, <code>PersistentCityProduction</code>, and <code>EmbarkWrapper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>TensorBase</code> <p>A FreecivBaseEnv instance that has been wrapped by TensorBase.</p> required <p>Attributes:</p> Name Type Description <code>aciton_config</code> <code>dict</code> <p>a dict that configs that specify sizes of mutable entities and action layout.</p> <code>mask</code> <code>dict</code> <p>a dict of masks of type numpy ndarray indicating available actions and entities. 0-&gt; unavilalbe, 1-&gt;availble.</p> <code>available_actions</code> <code>dict</code> <p>cached info['available_actions'], a dict that indicates available actions.</p> <code>action_space</code> <code>Dict</code> <p>a gymnasium.spaces.Dict with keys <code>['actor_type','city_id','unit_id', 'dipl_id','city_action_type','unit_action_type','dipl_action_type', 'gov_action_type','tech_action_type']</code></p> Source code in <code>src/civrealm/envs/freeciv_wrapper/action_wrapper.py</code> <pre><code>class TensorAction(Wrapper):\n    \"\"\"\n    A wrapper that defines tensor action spaces,  transforms tensor actions into\n    actions that could be handeled by FreecivBaseEnv instance, and adds masks to\n    observations.\n\n    TensorAction wrapper is composed of five wrappers, including `TruncateDiplCity`,\n    `DiplomacyLoop`, `CombineTechResearchGoal`, `PersistentCityProduction`, and `EmbarkWrapper`.\n\n\n\n    Parameters\n    ----------\n    env: TensorBase\n        A FreecivBaseEnv instance that has been wrapped by TensorBase.\n\n    Attributes\n    ----------\n    aciton_config: dict\n        a dict that configs that specify sizes of mutable entities and action layout.\n    mask: dict\n        a dict of masks of type numpy ndarray indicating available actions and entities. 0-&gt; unavilalbe, 1-&gt;availble.\n    available_actions: dict\n        cached info['available_actions'], a dict that indicates available actions.\n    action_space: gymnasium.spaces.Dict\n        a gymnasium.spaces.Dict with keys `['actor_type','city_id','unit_id',\n        'dipl_id','city_action_type','unit_action_type','dipl_action_type',\n        'gov_action_type','tech_action_type']`\n    \"\"\"\n\n    def __init__(self, env: TensorBase):\n        self.action_config = env.get_wrapper_attr(\"config\")\n        self.action_config[\"resize\"][\"dipl\"] = self.action_config[\"resize\"][\n            \"others_player\"\n        ]\n        self.actor_type_list = self.action_config[\"actor_type_list\"]\n        self.available_actions = {}\n        self.mask = {}\n        self.__turn = -1\n        self.__dealing_with_incoming = False\n\n        super().__init__(\n            TruncateDiplCity(\n                DiplomacyLoop(\n                    CombineTechResearchGoal(\n                        PersistentCityProduction(EmbarkWrapper(env))\n                    )\n                )\n            )\n        )\n\n        self.action_space = spaces.Dict(\n            {\n                \"actor_type\": spaces.Discrete(len(self.actor_type_list)),\n                \"city_id\": spaces.Discrete(self.action_config[\"resize\"][\"city\"]),\n                \"city_action_type\": spaces.Discrete(\n                    sum(self.action_config[\"action_layout\"][\"city\"].values())\n                ),\n                \"unit_id\": spaces.Discrete(self.action_config[\"resize\"][\"unit\"]),\n                \"unit_action_type\": spaces.Discrete(\n                    sum(self.action_config[\"action_layout\"][\"unit\"].values())\n                ),\n                \"dipl_id\": spaces.Discrete(self.action_config[\"resize\"][\"dipl\"]),\n                \"dipl_action_type\": spaces.Discrete(\n                    sum(self.action_config[\"action_layout\"][\"dipl\"].values())\n                ),\n                \"gov_action_type\": spaces.Discrete(\n                    sum(self.action_config[\"action_layout\"][\"gov\"].values())\n                ),\n                \"tech_action_type\": spaces.Discrete(\n                    sum(self.action_config[\"action_layout\"][\"tech\"].values())\n                ),\n            }\n        )\n\n    def step(self, action):\n        # Get {k:value.item()} if value is array\n        action = {\n            k: (v.item() if isinstance(v, np.ndarray) else v) for k, v in action.items()\n        }\n\n        base_action = self.action(action)\n        if tensor_debug:\n            print(base_action)\n        obs, reward, terminated, truncated, info = self.env.step(base_action)\n        if tensor_debug:\n            print(f\"reward:{reward},done:{terminated or truncated}\")\n\n        obs = self.update_obs_with_mask(obs, info, action)\n        return obs, reward, terminated, truncated, info\n\n    def reset(\n        self,\n        *,\n        seed: Optional[int] = None,\n        options: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        obs, info = self.env.reset(seed=seed, options=options, **kwargs)\n        obs = self.update_obs_with_mask(obs, info)\n        return obs, info\n\n    def action(self, action):\n        \"\"\"\n        Translate tensor action, a dict of keys `['actor_type','city_id','unit_id',\n        'dipl_id','city_action_type','unit_action_type','dipl_action_type',\n        'gov_action_type','tech_action_type']` to `FreecivBaseEnv` action,\n        a tuple `(actor_type, entity_id, action_name)`.\n\n        \"\"\"\n        if tensor_debug:\n            self._check_action_layout()\n\n        actor_type = action[\"actor_type\"]\n        actor_name = self.actor_type_list[actor_type]\n\n        if actor_name == \"turn done\":\n            return None\n        if actor_name in [\"gov\", \"tech\"]:\n            entity_pos = None\n            entity_id = self.get_wrapper_attr(\"my_player_id\")\n            action_index = action[actor_name + \"_action_type\"]\n        else:\n            entity_pos, action_index = (\n                action[actor_name + \"_id\"],\n                action[actor_name + \"_action_type\"],\n            )\n            entity_id = self.get_wrapper_attr(actor_name + \"_ids\")[\n                action[actor_name + \"_id\"]\n            ]\n\n        if tensor_debug:\n            assert (\n                self.mask[actor_name + \"_action_type_mask\"][entity_pos, action_index]\n                == 1\n            ), f\"{actor_name} action of id pos {entity_pos}, \\\n                    action type index {action_index} is masked\"\n\n        action_name = sorted(\n            list(self.available_actions[actor_name][entity_id].keys())\n        )[action_index]\n\n        return (actor_name, entity_id, action_name)\n\n    def update_obs_with_mask(self, observation, info, action=None):\n        \"\"\"\n        Update self.mask using observation, info and action from the unwrapped env,\n        and add self.mask to the observation of the wrapped env.\n        \"\"\"\n        if info[\n            \"turn\"\n        ] != self.__turn or self.__dealing_with_incoming != self.get_wrapper_attr(\n            \"dealing_with_incoming\"\n        ):\n            self.reset_mask()\n        self.available_actions = deepcopy(info[\"available_actions\"])\n        self.__turn = info[\"turn\"]\n        self.__dealing_with_incoming = self.get_wrapper_attr(\"dealing_with_incoming\")\n        self._update_mask(observation, info, action)\n\n        return update(observation, deepcopy(self.mask))\n\n    def reset_mask(self):\n        \"\"\"\n        Reset self.mask\n\n        This is usually called at the start of a new turn to reset masks.\n        \"\"\"\n        # Reset mask\n        sizes = self.action_config[\"resize\"]\n        self.mask[\"actor_type_mask\"] = np.ones(\n            len(self.actor_type_list), dtype=np.int32\n        )\n\n        # Units/Cities/Players and others Masks\n        for field in [\"unit\", \"city\", \"others_unit\", \"others_city\", \"others_player\"]:\n            self.mask[field + \"_mask\"] = np.ones(sizes[field], dtype=np.int32)[\n                ..., np.newaxis\n            ]\n\n        # Units/Cities Id Masks same as their Masks\n        self.mask[\"unit_id_mask\"] = self.mask[\"unit_mask\"]\n        self.mask[\"city_id_mask\"] = self.mask[\"city_mask\"]\n\n        # Dipl id mask\n        self.mask[\"dipl_id_mask\"] = np.ones(sizes[\"dipl\"], dtype=np.int32)[\n            ..., np.newaxis\n        ]\n\n        # Action type mask\n        for field in [\"city\", \"unit\", \"dipl\"]:\n            self.mask[field + \"_action_type_mask\"] = np.ones(\n                (\n                    sizes[field],\n                    sum(self.action_config[\"action_layout\"][field].values()),\n                ),\n                dtype=np.int32,\n            )\n        for field in [\"gov\", \"tech\"]:\n            self.mask[field + \"_action_type_mask\"] = np.ones(\n                (sum(self.action_config[\"action_layout\"][field].values()),),\n                dtype=np.int32,\n            )\n\n    def _update_mask(self, observation, info, action):\n        # update self.mask using action, observation and info\n        if action:\n            self._mask_from_action(action)\n        self._mask_from_obs(observation)\n        self._mask_from_info(info)\n\n    def _mask_from_action(self, action):\n        # Mask out actions that have been performed in this turn.\n        actor_type = action[\"actor_type\"]\n        actor_name = self.actor_type_list[actor_type]\n        if actor_name == \"unit\":\n            # self.mask[\"unit_action_type_mask\"][\n            #     action[\"unit_id\"], action[\"unit_action_type\"]\n            # ] = 0\n            pass\n        elif actor_name == \"city\":\n            # self.mask[\"city_action_type_mask\"][action[\"city_id\"], :] = 0\n            pass\n        elif actor_name == \"gov\":\n            self.mask[\"gov_action_type_mask\"][:] &amp;= 0\n        elif actor_name == \"tech\":\n            self.mask[\"tech_action_type_mask\"][:] &amp;= 0\n\n    def _mask_from_obs(self, observation):\n        # Mask mutable entities using observation\n\n        # Mask out trailing spaces for unit and city\n        self.mask[\"unit_id_mask\"][len(self.get_wrapper_attr(\"unit_ids\")) : :, :] = 0\n        self.mask[\"city_id_mask\"][len(self.get_wrapper_attr(\"city_ids\")) : :, :] = 0\n        self.mask[\"dipl_id_mask\"][len(self.get_wrapper_attr(\"dipl_ids\")) : :, :] = 0\n        self.mask[\"unit_mask\"] = self.mask[\"unit_id_mask\"].copy()\n        self.mask[\"city_mask\"] = self.mask[\"city_id_mask\"].copy()\n\n        self.mask[\"unit_action_type_mask\"][\n            len(self.get_wrapper_attr(\"unit_ids\")) : :, :\n        ] = 0\n        self.mask[\"city_action_type_mask\"][\n            len(self.get_wrapper_attr(\"city_ids\")) : :, :\n        ] = 0\n\n        # Mask Unit\n        for pos, unit_id in enumerate(\n            self.get_wrapper_attr(\"unit_ids\")[: self.action_config[\"resize\"][\"unit\"]]\n        ):\n            unit = observation[\"unit\"][unit_id]\n            if unit[\"moves_left\"] == 0 or self.unwrapped.civ_controller.unit_ctrl.units[\n                unit_id\n            ][\"activity\"] not in [\n                ACTIVITY_IDLE,\n                ACTIVITY_FORTIFIED,\n                ACTIVITY_SENTRY,\n                ACTIVITY_FORTIFYING,\n            ]:  # agent busy or fortified\n                self.mask[\"unit_id_mask\"][pos] &amp;= 0\n                self.mask[\"unit_action_type_mask\"][pos, :] &amp;= 0\n\n        self.mask[\"others_unit_mask\"][\n            len(self.get_wrapper_attr(\"others_unit_ids\")) : :, :\n        ] &amp;= 0\n        self.mask[\"others_city_mask\"][\n            len(self.get_wrapper_attr(\"others_city_ids\")) : :, :\n        ] &amp;= 0\n\n        if self.get_wrapper_attr(\"researching\"):\n            self.mask[\"tech_action_type_mask\"][:] &amp;= 0\n        if not self.get_wrapper_attr(\"researching\") and tensor_debug:\n            print(f\"techs_researched: {self.get_wrapper_attr('techs_researched')}\")\n\n    def _mask_from_info(self, info):\n        others_player_num = len(info[\"available_actions\"].get(\"player\", {}).keys())\n        self.mask[\"others_player_mask\"][others_player_num::, :] &amp;= 0\n\n        # Mask City and Unit\n        for mutable in [\"city\", \"unit\", \"dipl\"]:\n            entities = info[\"available_actions\"].get(mutable, {})\n            if len(entities) == 0:\n                self.mask[mutable + \"_action_type_mask\"][:, :] &amp;= 0\n                self.mask[mutable + \"_id_mask\"][:] &amp;= 0\n                continue\n            for i, entity_id in enumerate(\n                self.env.get_wrapper_attr(mutable + \"_ids\")[\n                    : self.action_config[\"resize\"][mutable]\n                ]\n            ):\n                actions = entities.get(entity_id, {})\n                if len(actions) == 0:\n                    self.mask[mutable + \"_action_type_mask\"][i, :] &amp;= 0\n                    self.mask[mutable + \"_id_mask\"][i] &amp;= 0\n                    continue\n                for action_id, act_name in enumerate(sorted(list(actions.keys()))):\n                    self.mask[mutable + \"_action_type_mask\"][i, action_id] &amp;= int(\n                        actions[act_name]\n                    )\n                self.mask[mutable + \"_id_mask\"][i] &amp;= int(\n                    any(self.mask[mutable + \"_action_type_mask\"][i])\n                )\n        for mutable in [\"city\", \"unit\", \"dipl\"]:\n            actor_type_index = self.actor_type_list.index(mutable)\n            self.mask[\"actor_type_mask\"][actor_type_index] &amp;= int(\n                any(self.mask[mutable + \"_id_mask\"])\n            )\n\n        # Mask Gov and Tech\n        for immutable in [\"gov\", \"tech\"]:\n            options = info[\"available_actions\"].get(immutable, {})\n            if len(options) == 0:\n                self.mask[immutable + \"_action_type_mask\"][:] &amp;= 0\n                continue\n            my_player_id = self.get_wrapper_attr(\"my_player_id\")\n            for action_id, act_name in enumerate(\n                sorted(list(options[my_player_id].keys()))\n            ):\n                self.mask[immutable + \"_action_type_mask\"][action_id] &amp;= int(\n                    options[my_player_id][act_name]\n                )\n        for immutable in [\"gov\", \"tech\"]:\n            actor_type_index = self.actor_type_list.index(immutable)\n            self.mask[\"actor_type_mask\"][actor_type_index] &amp;= int(\n                any(self.mask[immutable + \"_action_type_mask\"])\n            )\n\n    def _check_action_layout(self):\n        action_layout = self.action_config[\"action_layout\"]\n        for field in [\"city\", \"unit\"]:\n            for id, entity in self.available_actions.get(field, {}).items():\n                assert len(entity) == sum(action_layout[field].values())\n        assert len(\n            self.available_actions[\"gov\"][self.get_wrapper_attr(\"my_player_id\")]\n        ) == sum(action_layout[\"gov\"].values())\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.action_wrapper.TensorAction.action","title":"<code>action(action)</code>","text":"<p>Translate tensor action, a dict of keys <code>['actor_type','city_id','unit_id', 'dipl_id','city_action_type','unit_action_type','dipl_action_type', 'gov_action_type','tech_action_type']</code> to <code>FreecivBaseEnv</code> action, a tuple <code>(actor_type, entity_id, action_name)</code>.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/action_wrapper.py</code> <pre><code>def action(self, action):\n    \"\"\"\n    Translate tensor action, a dict of keys `['actor_type','city_id','unit_id',\n    'dipl_id','city_action_type','unit_action_type','dipl_action_type',\n    'gov_action_type','tech_action_type']` to `FreecivBaseEnv` action,\n    a tuple `(actor_type, entity_id, action_name)`.\n\n    \"\"\"\n    if tensor_debug:\n        self._check_action_layout()\n\n    actor_type = action[\"actor_type\"]\n    actor_name = self.actor_type_list[actor_type]\n\n    if actor_name == \"turn done\":\n        return None\n    if actor_name in [\"gov\", \"tech\"]:\n        entity_pos = None\n        entity_id = self.get_wrapper_attr(\"my_player_id\")\n        action_index = action[actor_name + \"_action_type\"]\n    else:\n        entity_pos, action_index = (\n            action[actor_name + \"_id\"],\n            action[actor_name + \"_action_type\"],\n        )\n        entity_id = self.get_wrapper_attr(actor_name + \"_ids\")[\n            action[actor_name + \"_id\"]\n        ]\n\n    if tensor_debug:\n        assert (\n            self.mask[actor_name + \"_action_type_mask\"][entity_pos, action_index]\n            == 1\n        ), f\"{actor_name} action of id pos {entity_pos}, \\\n                action type index {action_index} is masked\"\n\n    action_name = sorted(\n        list(self.available_actions[actor_name][entity_id].keys())\n    )[action_index]\n\n    return (actor_name, entity_id, action_name)\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.action_wrapper.TensorAction.reset_mask","title":"<code>reset_mask()</code>","text":"<p>Reset self.mask</p> <p>This is usually called at the start of a new turn to reset masks.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/action_wrapper.py</code> <pre><code>def reset_mask(self):\n    \"\"\"\n    Reset self.mask\n\n    This is usually called at the start of a new turn to reset masks.\n    \"\"\"\n    # Reset mask\n    sizes = self.action_config[\"resize\"]\n    self.mask[\"actor_type_mask\"] = np.ones(\n        len(self.actor_type_list), dtype=np.int32\n    )\n\n    # Units/Cities/Players and others Masks\n    for field in [\"unit\", \"city\", \"others_unit\", \"others_city\", \"others_player\"]:\n        self.mask[field + \"_mask\"] = np.ones(sizes[field], dtype=np.int32)[\n            ..., np.newaxis\n        ]\n\n    # Units/Cities Id Masks same as their Masks\n    self.mask[\"unit_id_mask\"] = self.mask[\"unit_mask\"]\n    self.mask[\"city_id_mask\"] = self.mask[\"city_mask\"]\n\n    # Dipl id mask\n    self.mask[\"dipl_id_mask\"] = np.ones(sizes[\"dipl\"], dtype=np.int32)[\n        ..., np.newaxis\n    ]\n\n    # Action type mask\n    for field in [\"city\", \"unit\", \"dipl\"]:\n        self.mask[field + \"_action_type_mask\"] = np.ones(\n            (\n                sizes[field],\n                sum(self.action_config[\"action_layout\"][field].values()),\n            ),\n            dtype=np.int32,\n        )\n    for field in [\"gov\", \"tech\"]:\n        self.mask[field + \"_action_type_mask\"] = np.ones(\n            (sum(self.action_config[\"action_layout\"][field].values()),),\n            dtype=np.int32,\n        )\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.action_wrapper.TensorAction.update_obs_with_mask","title":"<code>update_obs_with_mask(observation, info, action=None)</code>","text":"<p>Update self.mask using observation, info and action from the unwrapped env, and add self.mask to the observation of the wrapped env.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/action_wrapper.py</code> <pre><code>def update_obs_with_mask(self, observation, info, action=None):\n    \"\"\"\n    Update self.mask using observation, info and action from the unwrapped env,\n    and add self.mask to the observation of the wrapped env.\n    \"\"\"\n    if info[\n        \"turn\"\n    ] != self.__turn or self.__dealing_with_incoming != self.get_wrapper_attr(\n        \"dealing_with_incoming\"\n    ):\n        self.reset_mask()\n    self.available_actions = deepcopy(info[\"available_actions\"])\n    self.__turn = info[\"turn\"]\n    self.__dealing_with_incoming = self.get_wrapper_attr(\"dealing_with_incoming\")\n    self._update_mask(observation, info, action)\n\n    return update(observation, deepcopy(self.mask))\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.action_wrapper.EmbarkWrapper","title":"<code>envs.freeciv_wrapper.action_wrapper.EmbarkWrapper</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>Unify embark actions of all units to 'embark_{dir8}' where dir8 in <code>[0,...7]</code> indicating 8 directions.</p> <p>Sometimes a unit can embark multiple carrier on the same direction. In that case, the wrapper automatically choose the carrier with the smallest unit id.</p> <p>Attributes:</p> Name Type Description <code>embarkable_units</code> <code>dict</code> <p>a dict of embarkable units with key=(embarking_unit_id, dir8) and value=[carrier_ids]</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/embark_wrapper.py</code> <pre><code>@wrapper_override([\"action\", \"info\"])\nclass EmbarkWrapper(Wrapper):\n    \"\"\"\n    Unify embark actions of all units to 'embark_{dir8}' where dir8 in `[0,...7]`\n    indicating 8 directions.\n\n    Sometimes a unit can embark multiple carrier on the same direction. In that\n    case, the wrapper automatically choose the carrier with the smallest unit id.\n\n    Attributes\n    ----------\n    embarkable_units : dict\n        a dict of embarkable units with key=(embarking_unit_id, dir8) and value=[carrier_ids]\n    \"\"\"\n\n    def __init__(self, env):\n        self.embarkable_units = {}\n        super().__init__(env)\n\n    def action(self, action):\n        \"\"\"\n        Translate `embark_{dir8}` action into embark actions that can be handled by FreecivBaseEnv.\n        \"\"\"\n        if action is None:\n            return action\n        (actor_name, entity_id, action_name) = action\n        if actor_name != \"unit\":\n            return action\n        if action_name[:6] != \"embark\":\n            return action\n\n        dir8 = int(action_name.split(\"_\")[-1])\n\n        if len(self.embarkable_units.get((entity_id, dir8), [])) &gt; 0:\n            assert dir8 &lt;= 8\n            target_id = sorted(self.embarkable_units[(entity_id, dir8)])[0]\n            action_name = f\"embark_{dir8}_{target_id}\"\n\n        return (actor_name, entity_id, action_name)\n\n    def info(self, info):\n        \"\"\"\n        Complete or modify embark actions in info['availble_actions']['unit']\n\n        If a unit has no `embark_.*` action, then set all `embark_{dir8}` action to False\n\n        If a unit has `embark_{dir}=True`, set all `embark_{other_dirs}` action to False\n\n        If a unit has `embark_{carrier_id}_{dir}=True`, store that carrier_id\n        and set its `embark_{dir8}` accordingly.\n        \"\"\"\n\n        self.embarkable_units = {}\n        unit_actions = info[\"available_actions\"].get(\"unit\", {})\n\n        if len(unit_actions) == 0:\n            return info\n\n        for unit_id, actions in unit_actions.items():\n            unavailable_embarks = [\"embark_\" + f\"{i}\" for i in range(8)]\n            for action in list(actions.keys()):\n                if action[:6] != \"embark\":\n                    continue\n\n                args = action.split(\"_\")\n\n                if len(args) == 3:\n                    # action ==  embark_dir_id\n                    [dir8, target_id] = map(int, args[1::])\n                    if (unit_dir := (unit_id, dir8)) not in self.embarkable_units:\n                        self.embarkable_units[unit_dir] = [target_id]\n                    else:\n                        self.embarkable_units[unit_dir].append(target_id)\n                    actions.pop(action)\n                    embark_action = f\"embark_{dir8}\"\n                else:\n                    # action ==  embark_dir\n                    assert (\n                        len(args) == 2\n                    ), f\"Expected embark_{{dir}}_{{target_id}},\\\n                            but got unsupported embark action name {action}\"\n                    dir8 = int(action.split(\"_\")[-1])\n                    embark_action = f\"embark_{dir8}\"\n                actions[f\"embark_{dir8}\"] = True\n                if embark_action in unavailable_embarks:\n                    unavailable_embarks.remove(embark_action)\n\n            for embark_action in unavailable_embarks:\n                # set unavailable embark actions to False\n                actions[embark_action] = False\n\n        info[\"available_actions\"][\"unit\"] = unit_actions\n\n        return info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.action_wrapper.EmbarkWrapper.action","title":"<code>action(action)</code>","text":"<p>Translate <code>embark_{dir8}</code> action into embark actions that can be handled by FreecivBaseEnv.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/embark_wrapper.py</code> <pre><code>def action(self, action):\n    \"\"\"\n    Translate `embark_{dir8}` action into embark actions that can be handled by FreecivBaseEnv.\n    \"\"\"\n    if action is None:\n        return action\n    (actor_name, entity_id, action_name) = action\n    if actor_name != \"unit\":\n        return action\n    if action_name[:6] != \"embark\":\n        return action\n\n    dir8 = int(action_name.split(\"_\")[-1])\n\n    if len(self.embarkable_units.get((entity_id, dir8), [])) &gt; 0:\n        assert dir8 &lt;= 8\n        target_id = sorted(self.embarkable_units[(entity_id, dir8)])[0]\n        action_name = f\"embark_{dir8}_{target_id}\"\n\n    return (actor_name, entity_id, action_name)\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.action_wrapper.EmbarkWrapper.info","title":"<code>info(info)</code>","text":"<p>Complete or modify embark actions in info'availble_actions'</p> <p>If a unit has no <code>embark_.*</code> action, then set all <code>embark_{dir8}</code> action to False</p> <p>If a unit has <code>embark_{dir}=True</code>, set all <code>embark_{other_dirs}</code> action to False</p> <p>If a unit has <code>embark_{carrier_id}_{dir}=True</code>, store that carrier_id and set its <code>embark_{dir8}</code> accordingly.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/embark_wrapper.py</code> <pre><code>def info(self, info):\n    \"\"\"\n    Complete or modify embark actions in info['availble_actions']['unit']\n\n    If a unit has no `embark_.*` action, then set all `embark_{dir8}` action to False\n\n    If a unit has `embark_{dir}=True`, set all `embark_{other_dirs}` action to False\n\n    If a unit has `embark_{carrier_id}_{dir}=True`, store that carrier_id\n    and set its `embark_{dir8}` accordingly.\n    \"\"\"\n\n    self.embarkable_units = {}\n    unit_actions = info[\"available_actions\"].get(\"unit\", {})\n\n    if len(unit_actions) == 0:\n        return info\n\n    for unit_id, actions in unit_actions.items():\n        unavailable_embarks = [\"embark_\" + f\"{i}\" for i in range(8)]\n        for action in list(actions.keys()):\n            if action[:6] != \"embark\":\n                continue\n\n            args = action.split(\"_\")\n\n            if len(args) == 3:\n                # action ==  embark_dir_id\n                [dir8, target_id] = map(int, args[1::])\n                if (unit_dir := (unit_id, dir8)) not in self.embarkable_units:\n                    self.embarkable_units[unit_dir] = [target_id]\n                else:\n                    self.embarkable_units[unit_dir].append(target_id)\n                actions.pop(action)\n                embark_action = f\"embark_{dir8}\"\n            else:\n                # action ==  embark_dir\n                assert (\n                    len(args) == 2\n                ), f\"Expected embark_{{dir}}_{{target_id}},\\\n                        but got unsupported embark action name {action}\"\n                dir8 = int(action.split(\"_\")[-1])\n                embark_action = f\"embark_{dir8}\"\n            actions[f\"embark_{dir8}\"] = True\n            if embark_action in unavailable_embarks:\n                unavailable_embarks.remove(embark_action)\n\n        for embark_action in unavailable_embarks:\n            # set unavailable embark actions to False\n            actions[embark_action] = False\n\n    info[\"available_actions\"][\"unit\"] = unit_actions\n\n    return info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.observation_wrapper.TensorObservation","title":"<code>envs.freeciv_wrapper.observation_wrapper.TensorObservation</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>A wrapper that defines tensor observation space, transforms observations got from FreecivBaseEnv into tensor observations.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>TensorBase</code> <p>A FreecivBaseEnv wrapped by TensorBase wrapper</p> required <p>Attributes:</p> Name Type Description <code>observation_config</code> <code>dict</code> <p>tensor observation configuration</p> <code>observation_space</code> <code>Dict</code> <p>a gymnasium.spaces.Dict with keys speficified in configuration; observation with keywords <code>mask</code> would not be removed.</p> <code>obs_initialized</code> <code>bool</code> <p>whether observation spaces has been initialized</p> <code>obs_layout</code> <code>dict</code> <p>a dict that specify shapes of flattened numpy arrays in observation</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/observation_wrapper.py</code> <pre><code>@wrapper_override([\"observation\"])\nclass TensorObservation(Wrapper):\n    \"\"\"\n    A wrapper that defines tensor observation space, transforms observations got from\n    FreecivBaseEnv into tensor observations.\n\n    Parameters\n    ----------\n    env:\n        A FreecivBaseEnv wrapped by TensorBase wrapper\n\n    Attributes\n    ---------\n    observation_config: dict\n        tensor observation configuration\n    observation_space: gymnasium.spaces.Dict\n        a gymnasium.spaces.Dict with keys speficified in configuration;\n        observation with keywords `mask` would not be removed.\n    obs_initialized: bool\n        whether observation spaces has been initialized\n    obs_layout: dict\n        a dict that specify shapes of flattened numpy arrays in observation\n    \"\"\"\n\n    mutable_fields = [\n        \"city\",\n        \"unit\",\n        \"others_city\",\n        \"others_unit\",\n        \"others_player\",\n        \"dipl\",\n    ]\n    immutable_fields = [\"map\", \"rules\", \"player\", \"gov\"]\n\n    def __init__(self, env: TensorBase):\n        self.obs_initialized = False\n        self.observation_config = env.get_wrapper_attr(\"config\")\n        self.observation_config[\"resize\"][\"dipl\"] = self.observation_config[\"resize\"][\n            \"others_player\"\n        ]\n        self.obs_layout = {}\n        self.others_player_ids = []\n        super().__init__(env)\n\n    def observation(self, observation):\n        \"\"\"\n        convert observations obtained from `FreecivBaseEnv` into a dict of flattend numpy arrays.\n        \"\"\"\n        # in case of gameover, return None as observation\n        if len(observation.get(\"player\", {})) == 0:\n            return None\n\n        observation = deepcopy(observation)\n        observation = self._merge_player_techs(observation)\n        obs_dict = self._handle_dict(observation)\n        obs = self._embed_immutable(deepcopy(obs_dict))\n        obs = self._embed_mutable(obs)\n\n        if not self.obs_initialized:\n            self.observation_space = self._infer_obs_space(obs)\n            self.obs_initialized = True\n        if tensor_debug:\n            self._check_obs_layout(obs)\n        return obs\n\n    def _handle_dict(self, obs):\n        obs[\"city\"] = obs.get(\"city\", {})\n        obs[\"unit\"] = obs.get(\"unit\", {})\n\n        # TODO: This should be the base env's reponsibility\n        # Add info to city and unit from civcontroller\n        update(obs[\"city\"], self.unwrapped.civ_controller.city_ctrl.cities)\n        update(obs[\"unit\"], self.unwrapped.civ_controller.unit_ctrl.units)\n        # update player info with dipl_state\n        update(obs[\"player\"], obs.get(\"dipl\", {}))\n\n        my_player_id = self.get_wrapper_attr(\"my_player_id\")\n\n        obs[\"dipl\"] = {\n            player: state[\"diplomacy_clause_map\"]\n            for player, state in obs.get(\"dipl\", {}).items()\n            if player != my_player_id\n        }\n        for player, treaty in obs[\"dipl\"].items():\n            obs[\"dipl\"][player] = self._encode_treaty(treaty, player)\n\n        # remove unused fields and keep mask if given\n        obs = {\n            k: v\n            for k, v in obs.items()\n            if k in self.observation_config[\"filter_observation\"] or k.endswith(\"mask\")\n        }\n\n        # Add others fields and initialize\n\n        obs[\"others_unit\"] = {}\n        obs[\"others_city\"] = {}\n\n        for field in [\"unit\", \"city\"]:\n            for key, val in list(obs[field].items()):\n                if val[\"owner\"] != my_player_id:\n                    # delete others' entity from unit and city\n                    obs[\"others_\" + field][key] = obs[field].pop(key)\n\n        obs[\"others_player\"] = {\n            key: obs[\"player\"].pop(key)\n            for key in list(obs[\"player\"].keys())\n            if key != my_player_id\n        }\n        obs[\"player\"] = obs[\"player\"][my_player_id]\n\n        # Initialize build_cost with 0 for now\n        obs[\"rules\"][\"build_cost\"] = 0\n\n        mutable_fields = [field for field in obs.keys() if field in self.mutable_fields]\n        immutable_fields = [\n            field for field in obs.keys() if field in self.immutable_fields\n        ]\n\n        ops = self.observation_config[\"obs_ops\"]\n\n        # Handle immutable\n        # delete unused keywords and transform useful keywords\n        def apply_ops(field):\n            for k, val in list(obs[field].items()):\n                if k in list(ops[field].keys()):\n                    obs[field][k] = ops[field][k](val)\n                else:\n                    obs[field].pop(k)\n\n        for field in immutable_fields:\n            apply_ops(field)\n\n        # Handle mutable\n        # delete unused keywords and transform useful keywords\n        def apply_ops_mutable(field):\n            for entity_id, entity in list(obs[field].items()):\n                for k, val in list(entity.items()):\n                    if k in list(ops[field].keys()):\n                        entity[k] = ops[field][k](val)\n                    else:\n                        entity.pop(k)\n\n        for field in mutable_fields:\n            apply_ops_mutable(field)\n\n        self.others_player_ids = sorted(obs[\"others_player\"].keys())\n\n        return obs\n\n    def _embed_immutable(self, obs):\n        immutable = {\n            field: obs[field] for field in obs if field in self.immutable_fields\n        }\n\n        if not self.obs_initialized:\n            for field, field_dict in immutable.items():\n                self.obs_layout[field] = OrderedDict(\n                    [(k, field_dict[k].shape) for k in sorted(list(field_dict.keys()))]\n                )\n\n        for field, field_dict in immutable.items():\n            # check field layout is correct\n            if tensor_debug:\n                assert self.obs_layout[field] == {\n                    k: v.shape for k, v in field_dict.items()\n                }\n\n            obs[field] = np.concatenate(\n                [field_dict[k] for k in sorted(list(field_dict.keys()))], axis=-1\n            ).astype(np.int32)\n        return obs\n\n    def _embed_mutable(self, obs):\n        mutable = {field: obs[field] for field in obs if field in self.mutable_fields}\n        mutable_layout = self.observation_config[\"obs_mutable_layout\"]\n\n        if not self.obs_initialized:\n            for field, entity_dict in mutable.items():\n                layout = mutable_layout[field]\n                self.obs_layout[field] = OrderedDict(\n                    [(key, layout[key]) for key in sorted(layout)]\n                )\n\n        for field, entity_dict in mutable.items():\n            # for empty field, fill with zero\n            if len(entity_dict) == 0:\n                mutable[field] = np.zeros(\n                    [\n                        self.observation_config[\"resize\"][field],\n                        *reduce(add_shape, self.obs_layout[field].values()),\n                    ],\n                    dtype=np.int32,\n                )\n                continue\n            if tensor_debug:\n                # check entity layout is correct\n                assert all(\n                    self.obs_layout[field] == {k: v.shape for k, v in entity.items()}\n                    for entity in entity_dict.values()\n                )\n            # combine every entity's properties into an array along the last axis\n            entity_dict = {\n                id: np.concatenate([entity[k] for k in sorted(entity.keys())], axis=-1)\n                for id, entity in entity_dict.items()\n            }\n            # combine all entities in a field into an array along the first axis\n            mutable[field] = np.stack(\n                [entity_dict[id] for id in self.get_wrapper_attr(field + \"_ids\")],\n                axis=0,\n            ).astype(np.int32)\n\n        # resize to maximum entity shape\n        for field in mutable:\n            size = self.observation_config[\"resize\"][field]\n            mutable[field] = resize_data(mutable[field], size).astype(np.int32)\n\n        update(obs, mutable)\n        return obs\n\n    def _infer_obs_space(self, observation) -&gt; spaces.Dict:\n        return spaces.Dict(\n            [\n                (key, spaces.Box(low=0, high=1000, shape=space.shape, dtype=np.int32))\n                for key, space in observation.items()\n            ]\n        )\n\n    def _check_obs_layout(self, obs):\n        for field, val in self.obs_layout.items():\n            shape = reduce(add_shape, val.values())\n            assert shape[-1] == obs[field].shape[-1]\n\n    def _merge_player_techs(self, obs):\n        for player in obs[\"player\"].values():\n            player[\"techs\"] = []\n            for tech in sorted(obs[\"tech\"]):\n                player_tech = player.pop(f\"tech_{tech}\")\n                player[\"techs\"].append(player_tech if player_tech is not None else 255)\n        return obs\n\n    def _encode_treaty(self, treaty, player):\n        encoded = {\n            \"type\": np.zeros(10 * 2, dtype=np.int32),\n            \"give_city\": np.zeros(\n                self.observation_config[\"resize\"][\"city\"], dtype=np.int32\n            ),\n            \"ask_city\": np.zeros(\n                self.observation_config[\"resize\"][\"others_city\"], dtype=np.int32\n            ),\n            \"give_gold\": 255,\n            \"ask_gold\": 255,\n        }\n\n        for clause in treaty:\n            value = clause[\"value\"]\n\n            if clause[\"type\"] == player_const.CLAUSE_GOLD:\n                gold = sum(int(value &gt;= level) for level in GOLD_SET)\n                if clause[\"giver\"] == player:\n                    encoded[\"ask_gold\"] = gold\n                else:\n                    encoded[\"give_gold\"] = gold\n            elif clause[\"type\"] == player_const.CLAUSE_CITY:\n                if clause[\"giver\"] == player:\n                    city_list = self.get_wrapper_attr(\"others_city_ids\")\n                    field = \"ask_city\"\n                else:\n                    city_list = self.get_wrapper_attr(\"city_ids\")\n                    field = \"give_city\"\n                if value in city_list:\n                    city_idx = city_list.index(value)\n                    encoded[field][city_idx] = 1\n\n            if clause[\"giver\"] == player:\n                encoded[\"type\"][clause[\"type\"]] = 1\n            else:\n                encoded[\"type\"][clause[\"type\"] + 10] = 1\n\n        return encoded\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.observation_wrapper.TensorObservation.observation","title":"<code>observation(observation)</code>","text":"<p>convert observations obtained from <code>FreecivBaseEnv</code> into a dict of flattend numpy arrays.</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/observation_wrapper.py</code> <pre><code>def observation(self, observation):\n    \"\"\"\n    convert observations obtained from `FreecivBaseEnv` into a dict of flattend numpy arrays.\n    \"\"\"\n    # in case of gameover, return None as observation\n    if len(observation.get(\"player\", {})) == 0:\n        return None\n\n    observation = deepcopy(observation)\n    observation = self._merge_player_techs(observation)\n    obs_dict = self._handle_dict(observation)\n    obs = self._embed_immutable(deepcopy(obs_dict))\n    obs = self._embed_mutable(obs)\n\n    if not self.obs_initialized:\n        self.observation_space = self._infer_obs_space(obs)\n        self.obs_initialized = True\n    if tensor_debug:\n        self._check_obs_layout(obs)\n    return obs\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.observation_wrapper.CacheLastObs","title":"<code>envs.freeciv_wrapper.observation_wrapper.CacheLastObs</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>Cache last observation, and override observation with cached observation if terminated or truncated.</p> <p>Attributes:</p> Name Type Description <code>cached_last_obs</code> <code>dict</code> <p>observation cached from the last call of step() or reset()</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/observation_wrapper.py</code> <pre><code>class CacheLastObs(Wrapper):\n    \"\"\"\n    Cache last observation, and override observation with cached observation\n    if terminated or truncated.\n\n    Attributes\n    -------------\n    cached_last_obs: dict\n        observation cached from the last call of step() or reset()\n    \"\"\"\n\n    def __init__(self, env):\n        self.cached_last_obs = None\n        super().__init__(env)\n\n    def step(self, action):\n        obs, reward, terminated, truncated, info = self.env.step(action)\n\n        if terminated or truncated:\n            obs = self.cached_last_obs\n            info = {} if info is None else info\n            return obs, reward, terminated, truncated, info\n\n        self.cached_last_obs = deepcopy(obs)\n        return obs, reward, terminated, truncated, info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.llm_wrapper.LLMWrapper","title":"<code>envs.freeciv_wrapper.llm_wrapper.LLMWrapper</code>","text":"<p>             Bases: <code>Wrapper</code></p> <p>A wrapper for llm. It tells the surrounding observations of each unit and city extracted from FreecivBaseEnv, based on which llm can generate actions for units and cities. It transforms action_keys of actions from FreecivBaseEnv to readable action_names such that llm can understand. After llm have chosen an action and return the action_name to env, this wrapper transforms the action_name to an action_key, and then execute the corresponding action.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>FreecivBaseEnv</code> <p>A FreecivBaseEnv</p> required <p>Attributes:</p> Name Type Description <code>llm_default_settings</code> <code>dict</code> <p>settings for llm_wrapper.</p> <code>action_names</code> <code>dict</code> <p>a dict matches action_keys from FreecivBaseEnv to readable action_names</p> <code>tile_length_radius</code> <code>int</code> <p>(length of a tile - 1) / 2</p> <code>tile_width_radius</code> <code>int</code> <p>(width of a tile - 1) / 2</p> <code>tile_info_template</code> <code>dict</code> <p>a dict describes detailed surrounding observations of a unit or a city</p> <code>block_length_radius</code> <code>int</code> <p>(length of a block - 1) / 2</p> <code>block_width_radius</code> <code>int</code> <p>(width of a block - 1) / 2</p> <code>block_info_template</code> <code>dict</code> <p>a dict describes zoomed-out surrounding observations of a unit or a city</p> <code>ctrl_types</code> <code>list</code> <p>a list describes which components of the game to control by llm; we temporarily only consider unit and city in llm_wrapper</p> <code>ctrl_action_categories</code> <code>dict</code> <p>a dict describes which categories of actions llm can take; it can be seen as an action mask</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/llm_wrapper.py</code> <pre><code>class LLMWrapper(Wrapper):\n    \"\"\"\n    A wrapper for llm. It tells the surrounding observations of each unit and city extracted from FreecivBaseEnv, based\n    on which llm can generate actions for units and cities. It transforms action_keys of actions from FreecivBaseEnv to\n    readable action_names such that llm can understand. After llm have chosen an action and return the action_name to\n    env, this wrapper transforms the action_name to an action_key, and then execute the corresponding action.\n\n    Parameters\n    ----------\n    env:\n        A FreecivBaseEnv\n\n    Attributes\n    ---------\n    llm_default_settings: dict\n        settings for llm_wrapper.\n    action_names: dict\n        a dict matches action_keys from FreecivBaseEnv to readable action_names\n    tile_length_radius: int\n        (length of a tile - 1) / 2\n    tile_width_radius: int\n        (width of a tile - 1) / 2\n    tile_info_template: dict\n        a dict describes detailed surrounding observations of a unit or a city\n    block_length_radius: int\n        (length of a block - 1) / 2\n    block_width_radius: int\n        (width of a block - 1) / 2\n    block_info_template: dict\n        a dict describes zoomed-out surrounding observations of a unit or a city\n    ctrl_types: list\n        a list describes which components of the game to control by llm; we temporarily only consider unit and city in\n        llm_wrapper\n    ctrl_action_categories: dict\n        a dict describes which categories of actions llm can take; it can be seen as an action mask\n    \"\"\"\n\n    def __init__(self, env: FreecivBaseEnv):\n        super().__init__(env)\n        self.llm_default_settings = parse_llm_default_settings()\n\n        (self.action_names, self.tile_length_radius, self.tile_width_radius, self.tile_info_template,\n         self.block_length_radius, self.block_width_radius, self.block_info_template, self.ctrl_types,\n         self.ctrl_action_categories) = self.llm_default_settings.values()\n\n        self.action_keys = {val: key for key, val in self.action_names.items()}\n        self.controller = self.unwrapped.civ_controller\n\n    def reset(self, seed=None, options=None, **kwargs):\n        if 'minitask_pattern' in kwargs:\n            observation, info = self.env.reset(minitask_pattern=kwargs['minitask_pattern'])\n        else:\n            observation, info = self.env.reset()\n\n        info['llm_info'] = self.get_llm_info(observation, info)\n        info['my_player_id'] = self.controller.player_ctrl.my_player_id\n        return observation, info\n\n    def step(self, action):\n        if action is not None:\n            action_name = action[2]\n            action = (action[0], action[1], get_action_from_readable_name(action_name, self.action_keys))\n\n        observation, reward, terminated, truncated, info = self.env.step(action)\n        info['llm_info'] = self.get_llm_info(observation, info)\n        info['my_player_id'] = self.controller.player_ctrl.my_player_id\n        return observation, reward, terminated, truncated, info\n\n    def get_llm_info(self, obs, info):\n        \"\"\"\n        Convert observations and available actions of all actors from `FreecivBaseEnv` into a dict of natural language\n        \"\"\"\n        current_turn = info['turn']\n\n        llm_info = dict()\n        for ctrl_type, actors_can_act in info['available_actions'].items():\n            llm_info[ctrl_type] = dict()\n\n            if ctrl_type == 'unit':\n                units = self.controller.unit_ctrl.units\n                for unit_id in actors_can_act:\n                    if (units[unit_id]['type'] == 1 and units[unit_id]['activity'] not in\n                            [ACTIVITY_IDLE, ACTIVITY_FORTIFIED, ACTIVITY_SENTRY, ACTIVITY_FORTIFYING]):\n                        continue\n\n                    x = obs[ctrl_type][unit_id]['x']\n                    y = obs[ctrl_type][unit_id]['y']\n                    utype = obs[ctrl_type][unit_id]['type_rule_name']\n\n                    unit_dict = self.get_actor_info(x, y, obs, info, ctrl_type, unit_id, utype)\n                    if unit_dict:\n                        llm_info[ctrl_type][unit_id] = unit_dict\n\n            elif ctrl_type == 'city':\n                for city_id in actors_can_act:\n                    # The following two conditions are used to check if 1.  the city is just built or is building\n                    # coinage, and 2. the city has just built a unit or an improvement last turn and there are some\n                    # production points left in stock.\n                    if (obs[ctrl_type][city_id]['prod_process'] == 0 or\n                            current_turn == obs[ctrl_type][city_id]['turn_last_built'] + 1):\n                        x = obs[ctrl_type][city_id]['x']\n                        y = obs[ctrl_type][city_id]['y']\n\n                        city_dict = self.get_actor_info(x, y, obs, info, ctrl_type, city_id)\n                        if city_dict:\n                            llm_info[ctrl_type][city_id] = city_dict\n                    else:\n                        continue\n            else:\n                continue\n\n        return llm_info\n\n    def get_actor_info(self, x, y, obs, info, ctrl_type, actor_id, utype=None):\n        \"\"\"\n        Convert observations and available actions of a specific actor from `FreecivBaseEnv` into a dict of natural language\n        \"\"\"\n        actor_info = dict()\n\n        actor_name = None\n        if ctrl_type == 'unit':\n            actor_name = utype + ' ' + str(actor_id)\n        elif ctrl_type == 'city':\n            actor_name = ctrl_type + ' ' + str(actor_id)\n        actor_info['name'] = actor_name\n\n        available_actions = get_valid_actions(info, ctrl_type, actor_id)\n        if not available_actions or (len(available_actions) == 1 and available_actions[0] == 'keep_activity'):\n            return dict()\n        else:\n            if ctrl_type not in self.ctrl_action_categories:\n                actor_info['available_actions'] = make_action_list_readable(available_actions, self.action_names)\n            else:\n                actor_info['available_actions'] = make_action_list_readable(action_mask(self.ctrl_action_categories[ctrl_type], available_actions), self.action_names)\n\n        actor_info['observations'] = dict()\n        actor_info['observations']['minimap'] = self.get_mini_map_info(x, y, self.tile_length_radius, self.tile_width_radius, self.tile_info_template)\n        actor_info['observations']['upper_map'] = self.get_mini_map_info(x, y, self.block_length_radius, self.block_width_radius, self.block_info_template)\n\n        if ctrl_type == 'city':\n            actor_info['observations']['producing'] = self.get_city_producing(obs[ctrl_type], actor_id)\n\n        fc_logger.debug(f'actor observations: {actor_info}')\n\n        return actor_info\n\n    def get_city_producing(self, obs, actor_id):\n        producing = None\n        if obs[actor_id]['production_kind'] == VUT_UTYPE:\n            producing = self.controller.rule_ctrl.unit_types_list[obs[actor_id]['production_value'] - self.controller.rule_ctrl.ruleset_control['num_impr_types']]\n        elif obs[actor_id]['production_kind'] == VUT_IMPROVEMENT:\n            producing = self.controller.rule_ctrl.improvement_types_list[obs[actor_id]['production_value']]\n        return producing\n\n    def get_mini_map_info(self, x, y, length_r, width_r, template):\n        \"\"\"\n        Convert observations of a specific actor from `FreecivBaseEnv` into a dict of natural language\n        \"\"\"\n        mini_map_info = dict()\n\n        tile_id = 0\n        map_state = self.controller.map_ctrl.prop_state.get_state()\n        for ptile in template:\n            mini_map_info[ptile] = []\n            pdir = DIR[tile_id]\n            center_x = x + pdir[0] * (length_r * 2 + 1)\n            center_y = y + pdir[1] * (width_r * 2 + 1)\n\n            if not self.controller.map_ctrl.is_out_of_map(center_x, center_y):\n                \"\"\" consider map_const.TF_WRAPX == 1 \"\"\"\n                start_x = center_x - length_r\n                end_x = center_x + length_r + 1\n                start_y = center_y - width_r\n                end_y = center_y + width_r + 1\n\n                status_arr = read_sub_arr_with_wrap(map_state['status'], start_x, end_x, start_y, end_y)\n                terrain_arr = read_sub_arr_with_wrap(map_state['terrain'], start_x, end_x, start_y, end_y)\n                extras_arr = read_sub_arr_with_wrap(map_state['extras'], start_x, end_x, start_y, end_y)\n                unit_arr = read_sub_arr_with_wrap(map_state['unit'], start_x, end_x, start_y, end_y)\n                unit_owner_arr = read_sub_arr_with_wrap(map_state['unit_owner'], start_x, end_x, start_y, end_y)\n                city_owner_arr = read_sub_arr_with_wrap(map_state['city_owner'], start_x, end_x, start_y, end_y)\n\n                unexplored_tiles_num = len(list(status_arr[status_arr == 0]))\n                if unexplored_tiles_num &gt; 0:\n                    status_str = str(unexplored_tiles_num) + ' ' + 'tiles unexplored'\n                    mini_map_info[ptile].append(status_str)\n\n                for terrain_id, terrain in enumerate(TERRAIN_NAMES):\n                    terrains_num = len(list(terrain_arr[terrain_arr == terrain_id]))\n                    if terrains_num &gt; 0:\n                        terrain_str = str(terrains_num) + ' ' + terrain\n                        mini_map_info[ptile].append(terrain_str)\n\n                for extra_id, extra in enumerate(EXTRA_NAMES):\n                    extras_of_id = extras_arr[:, :, extra_id]\n                    extras_num = len(list(extras_of_id[extras_of_id != 0]))\n                    if extras_num &gt; 0:\n                        extra_str = str(extras_num) + ' ' + extra\n                        mini_map_info[ptile].append(extra_str)\n\n                for unit_id, unit in enumerate(self.controller.rule_ctrl.unit_types_list):\n                    units_of_id = unit_arr[:, :, unit_id]\n                    units_num = np.sum(units_of_id)\n                    if units_num &gt; 0:\n                        unit_str = str(int(units_num)) + ' ' + unit\n                        mini_map_info[ptile].append(unit_str)\n\n                unit_owners = list(unit_owner_arr[unit_owner_arr != 255])\n                if len(unit_owners) != 0:\n                    owner_set = []\n                    unit_owner_str = 'unit owners are:'\n                    for unit_owner in unit_owners:\n                        if unit_owner in owner_set:\n                            continue\n\n                        if unit_owner == self.controller.player_ctrl.my_player_id:\n                            unit_owner_str += ' myself player_' + str(int(unit_owner))\n                        else:\n                            ds_of_owner = self.controller.dipl_ctrl.diplstates[unit_owner]\n                            unit_owner_str += ' ' + DS_TXT[ds_of_owner] + ' player_' + str(int(unit_owner))\n                        owner_set.append(unit_owner)\n                    mini_map_info[ptile].append(unit_owner_str)\n\n                city_owners = list(city_owner_arr[city_owner_arr != 255])\n                for city_owner in self.controller.player_ctrl.players:\n                    owner_num = city_owners.count(city_owner)\n                    if owner_num == 0:\n                        continue\n\n                    if city_owner == self.controller.player_ctrl.my_player_id:\n                        city_owner_str = str(owner_num) + ' cities of myself player_' + str(int(city_owner))\n                    else:\n                        ds_of_owner = self.controller.dipl_ctrl.diplstates[city_owner]\n                        city_owner_str = (str(owner_num) + ' cities of a ' + DS_TXT[ds_of_owner] +\n                                          ' player_' + str(int(city_owner)))\n                    mini_map_info[ptile].append(city_owner_str)\n\n            tile_id += 1\n        return mini_map_info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.llm_wrapper.LLMWrapper.get_actor_info","title":"<code>get_actor_info(x, y, obs, info, ctrl_type, actor_id, utype=None)</code>","text":"<p>Convert observations and available actions of a specific actor from <code>FreecivBaseEnv</code> into a dict of natural language</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/llm_wrapper.py</code> <pre><code>def get_actor_info(self, x, y, obs, info, ctrl_type, actor_id, utype=None):\n    \"\"\"\n    Convert observations and available actions of a specific actor from `FreecivBaseEnv` into a dict of natural language\n    \"\"\"\n    actor_info = dict()\n\n    actor_name = None\n    if ctrl_type == 'unit':\n        actor_name = utype + ' ' + str(actor_id)\n    elif ctrl_type == 'city':\n        actor_name = ctrl_type + ' ' + str(actor_id)\n    actor_info['name'] = actor_name\n\n    available_actions = get_valid_actions(info, ctrl_type, actor_id)\n    if not available_actions or (len(available_actions) == 1 and available_actions[0] == 'keep_activity'):\n        return dict()\n    else:\n        if ctrl_type not in self.ctrl_action_categories:\n            actor_info['available_actions'] = make_action_list_readable(available_actions, self.action_names)\n        else:\n            actor_info['available_actions'] = make_action_list_readable(action_mask(self.ctrl_action_categories[ctrl_type], available_actions), self.action_names)\n\n    actor_info['observations'] = dict()\n    actor_info['observations']['minimap'] = self.get_mini_map_info(x, y, self.tile_length_radius, self.tile_width_radius, self.tile_info_template)\n    actor_info['observations']['upper_map'] = self.get_mini_map_info(x, y, self.block_length_radius, self.block_width_radius, self.block_info_template)\n\n    if ctrl_type == 'city':\n        actor_info['observations']['producing'] = self.get_city_producing(obs[ctrl_type], actor_id)\n\n    fc_logger.debug(f'actor observations: {actor_info}')\n\n    return actor_info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.llm_wrapper.LLMWrapper.get_llm_info","title":"<code>get_llm_info(obs, info)</code>","text":"<p>Convert observations and available actions of all actors from <code>FreecivBaseEnv</code> into a dict of natural language</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/llm_wrapper.py</code> <pre><code>def get_llm_info(self, obs, info):\n    \"\"\"\n    Convert observations and available actions of all actors from `FreecivBaseEnv` into a dict of natural language\n    \"\"\"\n    current_turn = info['turn']\n\n    llm_info = dict()\n    for ctrl_type, actors_can_act in info['available_actions'].items():\n        llm_info[ctrl_type] = dict()\n\n        if ctrl_type == 'unit':\n            units = self.controller.unit_ctrl.units\n            for unit_id in actors_can_act:\n                if (units[unit_id]['type'] == 1 and units[unit_id]['activity'] not in\n                        [ACTIVITY_IDLE, ACTIVITY_FORTIFIED, ACTIVITY_SENTRY, ACTIVITY_FORTIFYING]):\n                    continue\n\n                x = obs[ctrl_type][unit_id]['x']\n                y = obs[ctrl_type][unit_id]['y']\n                utype = obs[ctrl_type][unit_id]['type_rule_name']\n\n                unit_dict = self.get_actor_info(x, y, obs, info, ctrl_type, unit_id, utype)\n                if unit_dict:\n                    llm_info[ctrl_type][unit_id] = unit_dict\n\n        elif ctrl_type == 'city':\n            for city_id in actors_can_act:\n                # The following two conditions are used to check if 1.  the city is just built or is building\n                # coinage, and 2. the city has just built a unit or an improvement last turn and there are some\n                # production points left in stock.\n                if (obs[ctrl_type][city_id]['prod_process'] == 0 or\n                        current_turn == obs[ctrl_type][city_id]['turn_last_built'] + 1):\n                    x = obs[ctrl_type][city_id]['x']\n                    y = obs[ctrl_type][city_id]['y']\n\n                    city_dict = self.get_actor_info(x, y, obs, info, ctrl_type, city_id)\n                    if city_dict:\n                        llm_info[ctrl_type][city_id] = city_dict\n                else:\n                    continue\n        else:\n            continue\n\n    return llm_info\n</code></pre>"},{"location":"api_reference/api/#envs.freeciv_wrapper.llm_wrapper.LLMWrapper.get_mini_map_info","title":"<code>get_mini_map_info(x, y, length_r, width_r, template)</code>","text":"<p>Convert observations of a specific actor from <code>FreecivBaseEnv</code> into a dict of natural language</p> Source code in <code>src/civrealm/envs/freeciv_wrapper/llm_wrapper.py</code> <pre><code>def get_mini_map_info(self, x, y, length_r, width_r, template):\n    \"\"\"\n    Convert observations of a specific actor from `FreecivBaseEnv` into a dict of natural language\n    \"\"\"\n    mini_map_info = dict()\n\n    tile_id = 0\n    map_state = self.controller.map_ctrl.prop_state.get_state()\n    for ptile in template:\n        mini_map_info[ptile] = []\n        pdir = DIR[tile_id]\n        center_x = x + pdir[0] * (length_r * 2 + 1)\n        center_y = y + pdir[1] * (width_r * 2 + 1)\n\n        if not self.controller.map_ctrl.is_out_of_map(center_x, center_y):\n            \"\"\" consider map_const.TF_WRAPX == 1 \"\"\"\n            start_x = center_x - length_r\n            end_x = center_x + length_r + 1\n            start_y = center_y - width_r\n            end_y = center_y + width_r + 1\n\n            status_arr = read_sub_arr_with_wrap(map_state['status'], start_x, end_x, start_y, end_y)\n            terrain_arr = read_sub_arr_with_wrap(map_state['terrain'], start_x, end_x, start_y, end_y)\n            extras_arr = read_sub_arr_with_wrap(map_state['extras'], start_x, end_x, start_y, end_y)\n            unit_arr = read_sub_arr_with_wrap(map_state['unit'], start_x, end_x, start_y, end_y)\n            unit_owner_arr = read_sub_arr_with_wrap(map_state['unit_owner'], start_x, end_x, start_y, end_y)\n            city_owner_arr = read_sub_arr_with_wrap(map_state['city_owner'], start_x, end_x, start_y, end_y)\n\n            unexplored_tiles_num = len(list(status_arr[status_arr == 0]))\n            if unexplored_tiles_num &gt; 0:\n                status_str = str(unexplored_tiles_num) + ' ' + 'tiles unexplored'\n                mini_map_info[ptile].append(status_str)\n\n            for terrain_id, terrain in enumerate(TERRAIN_NAMES):\n                terrains_num = len(list(terrain_arr[terrain_arr == terrain_id]))\n                if terrains_num &gt; 0:\n                    terrain_str = str(terrains_num) + ' ' + terrain\n                    mini_map_info[ptile].append(terrain_str)\n\n            for extra_id, extra in enumerate(EXTRA_NAMES):\n                extras_of_id = extras_arr[:, :, extra_id]\n                extras_num = len(list(extras_of_id[extras_of_id != 0]))\n                if extras_num &gt; 0:\n                    extra_str = str(extras_num) + ' ' + extra\n                    mini_map_info[ptile].append(extra_str)\n\n            for unit_id, unit in enumerate(self.controller.rule_ctrl.unit_types_list):\n                units_of_id = unit_arr[:, :, unit_id]\n                units_num = np.sum(units_of_id)\n                if units_num &gt; 0:\n                    unit_str = str(int(units_num)) + ' ' + unit\n                    mini_map_info[ptile].append(unit_str)\n\n            unit_owners = list(unit_owner_arr[unit_owner_arr != 255])\n            if len(unit_owners) != 0:\n                owner_set = []\n                unit_owner_str = 'unit owners are:'\n                for unit_owner in unit_owners:\n                    if unit_owner in owner_set:\n                        continue\n\n                    if unit_owner == self.controller.player_ctrl.my_player_id:\n                        unit_owner_str += ' myself player_' + str(int(unit_owner))\n                    else:\n                        ds_of_owner = self.controller.dipl_ctrl.diplstates[unit_owner]\n                        unit_owner_str += ' ' + DS_TXT[ds_of_owner] + ' player_' + str(int(unit_owner))\n                    owner_set.append(unit_owner)\n                mini_map_info[ptile].append(unit_owner_str)\n\n            city_owners = list(city_owner_arr[city_owner_arr != 255])\n            for city_owner in self.controller.player_ctrl.players:\n                owner_num = city_owners.count(city_owner)\n                if owner_num == 0:\n                    continue\n\n                if city_owner == self.controller.player_ctrl.my_player_id:\n                    city_owner_str = str(owner_num) + ' cities of myself player_' + str(int(city_owner))\n                else:\n                    ds_of_owner = self.controller.dipl_ctrl.diplstates[city_owner]\n                    city_owner_str = (str(owner_num) + ' cities of a ' + DS_TXT[ds_of_owner] +\n                                      ' player_' + str(int(city_owner)))\n                mini_map_info[ptile].append(city_owner_str)\n\n        tile_id += 1\n    return mini_map_info\n</code></pre>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#installation","title":"Installation","text":"<p>We suggest using Conda to create a clean virtual environment for installation.</p> <p>Installation through the source code in the civrealm folder:</p> <pre><code>cd civrealm\npip install -e .\n</code></pre>"},{"location":"getting_started/quickstart/","title":"Quickstart","text":""},{"location":"getting_started/quickstart/#testing-the-installation","title":"Testing the installation","text":"<p>To test if the installation is successful, run</p> <pre><code>test_civrealm \n</code></pre> <p>To test with multiple players, run:</p> <pre><code>test_civrealm --minp=2 --username=myagent\n</code></pre> <p>Then start another terminal and run:</p> <pre><code>test_civrealm --username=myagent1\n</code></pre> <p>To observe the game play, you can access http://localhost:8080/ on a browser. Then, please click the \"Online Games\" button. You can find the running game under the \"MULTIPLAYER\" tab.</p>"},{"location":"getting_started/system_requirements/","title":"System Requirements","text":"<p>Civrealm requires Python version &gt;=3.8.</p> <p>In order to test the civrealm on http://localhost, please download the docker image from: https://drive.google.com/file/d/1tf32JpwqGN7AtUPe0Q4fIRkE4icSM-51/view?usp=sharing.</p> <p>:warning: Please make sure you have installed the latest docker engine and docker-compose. Using older versions of docker may result in unexpected erorrs.</p>"},{"location":"getting_started/trouble_shooting/","title":"Trouble shooting","text":"<p>The following are some common issues that you may encounter when running the code. If you encounter any other issues, please feel free to open an issue.</p> <ul> <li> <p>Note that each game corresponds to one port on the server. If one game just stops and you immediately start a new game connecting to the same port as the stopped game, the new game may encounter errors and exit. Our training has used ''Ports.get()'' in ''civrealm/freeciv/utils/port_utils.py'' to avoid the situation. If you want to configure the client port and start a client manually, you need to find the available ports by checking the 'Online Games/MULTIPLAYER' tab in localhost:8080.</p> </li> <li> <p>If firefox keeps loading the page, please try to add the following line to <code>/etc/hosts</code>:</p> <pre><code>127.0.0.1 maxcdn.bootstrapcdn.com\n127.0.0.1 cdn.webglstats.com\n</code></pre> </li> </ul>"},{"location":"misc/faq/","title":"FAQ","text":""},{"location":"misc/faq/#image-questions","title":"Image Questions","text":"\ud83e\udd14 1. When using the latest code from the official Freeciv-web GitHub repository to generate an image and executing the civrealm code, some unknown exceptions raise, how to solve this problem? <p>To enhance the functionality of the game, such as compatibility for loading saved files and adding script control during gameplay, we have undertaken development and optimization of freeciv-web. We\u2019ve forked a new branch to maximize compatibility with civrealm development. Using the official freeciv-web image from the website without compatibility testing may lead to unexpected errors. To improve your user experience, please utilize our branch\u2019s code to generate the image. Here\u2019s how: Open the releases page and select the appropriate freeciv-web tag based on the civrealm version.</p>"},{"location":"misc/resources/","title":"Resources","text":"<ul> <li>The official website for Freeciv, an open-source empire-building strategy game inspired by the history of human civilization, can be found at Freeciv.org.</li> <li>If you are new to freeciv, Freeciv Fandom is a nice tutorial to start with.</li> <li>If you are new to pytorch, pytorch tutorial is a official tutorial to start with.</li> </ul>"},{"location":"notes/contribute/","title":"Contribute to CivRealm","text":""},{"location":"notes/contribute/#development-process","title":"Development Process","text":"<ul> <li>For bugfix, we recommend that you raise them in the issue section, and have them fully discussed and verified by the developers.</li> </ul>"},{"location":"notes/contribute/#coding-styles","title":"Coding Styles","text":"<p>We follow the PEP8 style guide for python code development. The python comments follow NumPy style python docstrings.</p>"},{"location":"releases/releases/","title":"Releases","text":"CivRealm Version Freeciv-web Image Version Mini-Game Dataset 0.1 tag 1.3 minitask.zip"}]}